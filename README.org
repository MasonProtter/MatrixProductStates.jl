* MatrixProductStates.jl

This is a package-in-progress in which I intend to implement a [[https://en.wikipedia.org/wiki/Density_matrix_renormalization_group][DMRG]]
algorithm over matrix product states as explained in Schollwöck's [[https://www.sciencedirect.com/science/article/pii/S0003491610001752][The
density-matrix renormalization group in the age of matrix product
states]]. This same project has been undertaken in [[https://github.com/0/LatticeSweeper.jl][LatticeSweeper.jl]]. 

The code in this repo is currently under development. Many things
do not work and even fewer things are tested. 

** Source Code
This readme is a literal document containing all of the source and
test code for the package.
*** Module Definition
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/MatrixProductStates.jl
module MatrixProductStates

using LinearAlgebra, TensorOperations, TensorCast, LowRankApprox, Arpack

export *, /, ==, ≈, isequal, adjoint, getindex, randn
export MPS, MPO, left, right, compress, imag_time_evolution, rightcanonical, leftcanonical 
export ground_state

include("utils.jl")
include("MPS.jl")
include("MPO.jl")
include("compression.jl")
include("contraction.jl")
include("timeevolution.jl")
include("groundstate.jl")

end
#+END_SRC
#+HTML: </details>
#+HTML: </p>
*** Utils
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/utils.jl
export ⊗, realize

A ⊗ B = kron(A, B)

realize(x::Number) = error("Unrecognized numerical type")
realize(x::Real) = x
function realize(x::Complex; ϵ=1e-13)
    abs(imag(x)) < ϵ || error("Non-zero imaginary component")
    real(x)
end

dg(M::Array{T, 4}) where {T} = permutedims(conj.(M), (2, 1, 3, 4))
dg(M::Array{T, 3}) where {T} = permutedims(conj.(M), (2, 1, 3))

#+END_SRC
#+HTML: </details>
#+HTML: </p>
*** Matrix Product States
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/MPS.jl
#---------------------------------------------------------------------
# Matrix Product States
"""
    MPS{L, T<:Number}

Matrix product state on L sites. 

The `i`th tensor in the state has indices `[aⁱ⁻¹, aⁱ, σⁱ]` where
`(aⁱ⁻¹, aⁱ)` are bond indices and `σⁱ` is the physical index.

A four site MPS would be diagrammatically represented

    σ¹          σ²          σ³          σ⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•     

Note that `a⁰` and `aᴸ` must be of dimension 1.
"""
struct MPS{L, T<:Number} 
    tensors::Vector{Array{T,3}}
end

Base.isequal(ψ::MPS, ϕ::MPS)     = (isequal(ψ.tensors, ϕ.tensors))
Base.isapprox(ψ::MPS, ϕ::MPS)   = isapprox(ψ.tensors, ϕ.tensors)

Base.eltype(::Type{MPS{L, T}}) where {L, T} = T

Base.length(::MPS{L, T}) where {L, T} = L

Base.size(::MPS{L, T}) where {L, T} = (L,)
Base.getindex(ψ::MPS, i::Int) = getindex(ψ.tensors, i)

Base.:(*)(ψ::MPS{L, T}, x::Number) where {L, T} = MPS{L,T}(ψ.tensors .* x)
Base.:(*)(x::Number, ψ::MPS) = ψ * x
Base.:(/)(ψ::MPS{L,T}, x::Number) where {L, T} = MPS{L,T}(ψ.tensors ./ x)
Base.copy(ψ::MPS{L, T}) where {L, T} = MPS{L,T}(copy(ψ.tensors))

function Base.randn(::Type{MPS{L, T}}, D::Int, d::Int) where {L, T}
    tensors = [randn(1, D, d), [randn(D, D, d) for _ in 2:(L-1)]..., randn(D, 1, d)]
    MPS{L, T}(tensors) |> leftcanonical |> rightcanonical
end

#+END_SRC


#+HTML: <details><summary>Constructors and printing</summary>
#+HTML: <p>

#+BEGIN_SRC julia :comments both :tangle src/MPS.jl


"""
    MPS(vs::Vector{Vector})
Create an `MPS` representing a product state (all bonds have dimension 1),
where each site is described by the corresponding element of `vs`.
"""
function MPS(vs::Vector{Vector{T}}) where {T}
    L = length(vs)

    tensrs = Vector{Array{T,3}}(undef, L)
    for i in 1:L
        tensrs[i] = reshape(copy(vs[i]), 1, 1, :)
    end

    MPS{L,T}(tensrs)
end

"""
    MPS(v::Vector, L)
Create an `MPS` for `L` sites representing a uniform product state (all bonds
have dimension 1), where each site is described by `v`.
"""
MPS(v::Vector, L) = MPS([v for _ in 1:L])

function Base.show(io::IO, ::MIME"text/plain", ψ::MPS{L, T}) where {L, T}
    d = length(ψ.tensors[2][1, 1, :])
    bonddims = [size(ψ[i][:, :, 1]) for i in 1:L]
    println(io, "Matrix product state on $L sites")
    _show_mps_dims(io, L, d, bonddims)
end

function Base.show(ψ::MPS{L, T}) where {L, T}
    d = length(ψ.tensors[2][1, 1, :])
    bonddims = [size(ψ[i][:, :, 1]) for i in 1:L]
    println("Matrix product state on $L sites")
    _show_mps_dims(L, d, bonddims)
end

function _show_mps_dims(io::IO, L, d, bonddims)
    println(io, "  Physical dimension: $d")
    print(io, "  Bond dimensions:   ")
    if L > 8
        for i in 1:8
            print(io, bonddims[i], " × ")
        end
        print(io, " ... × ", bonddims[L])
    else
        for i in 1:(L-1)
            print(io, bonddims[i], " × ")
        end
        print(io, bonddims[L])
    end
end

function Base.show(io::IO, ψ::MPS{L, T}) where {L, T}
    print(io, "MPO on $L sites")
end

#+END_SRC

#+HTML: </p>
#+HTML: </details>

#+HTML: <details><summary>Adjoint MPS</summary>
#+HTML: <p>

#+BEGIN_SRC julia :comments both :tangle src/MPS.jl

#---------------------------------------------------------------------
# Adjoint Matrix Product States 

function Base.adjoint(ψ::MPS{L, T}) where {L,T}
    Adjoint{T, MPS{L, T}}(ψ)
end

function Base.show(io::IO, ::MIME"text/plain", ψ::Adjoint{T, MPS{L, T}}) where {L, T}
    d = length(ψ.parent[2][1, 1, :])
    bonddims = reverse([reverse(size(ψ.parent[i][:, :, 1])) for i in 1:L])
    println(io, "Adjoint matrix product state on $L sites")
    _show_mps_dims(io, L, d, bonddims)
end

function Base.show(io::IO, ψ::Adjoint{T, MPS{L, T}}) where {L, T}
    print(io, "Adjoint MPO on $L sites")t
end

Base.size(::Adjoint{T, MPS{L, T}}) where {L, T} = (1, L)

function Base.getindex(ψ::Adjoint{T, MPS{L, T}}, args...) where {L, T}
    out = getindex(reverse(ψ.parent.tensors), args...)
    permutedims(conj.(out), (2, 1, 3))
end

adjoint_tensors(ψ::MPS) = reverse(conj.(permutedims.(ψ.tensors, [(2, 1, 3)])))
#+END_SRC

#+HTML: </p>
#+HTML: </details>

#+HTML: <details><summary>MPS Contraction</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/contraction.jl

"""
    Base.:(*)(ψ′::Adjoint{T, MPS{L, T}}, ϕ::MPS{L, T}) where {L, T}
representing
    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•       
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴
    σ′¹         σ′²         σ′³         σ′⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•
"""
function Base.:(*)(ψ′::Adjoint{T, MPS{L, T}}, ϕ::MPS{L, T}) where {L, T}
    ψ = ψ′.parent

    M   = ϕ.tensors[1]
    M̃dg = dg(ψ.tensors[1])
    
    @tensor cont[b₁, a₁] := M̃dg[b₁, 1, σ₁] * M[1, a₁, σ₁]
    
    for i in 2:L-1
        M   = ϕ.tensors[i]
        M̃dg = dg(ψ.tensors[i])

        @tensor cont[bᵢ, aᵢ] := M̃dg[bᵢ, bᵢ₋₁, σᵢ] * cont[bᵢ₋₁, aᵢ₋₁] * M[aᵢ₋₁, aᵢ, σᵢ]
    end
    M   = ϕ.tensors[L]
    M̃dg = dg(ψ.tensors[L])
    
    @tensor M̃dg[1, bᴸ⁻¹, σᴸ] * cont[bᴸ⁻¹, aᴸ⁻¹] * M[aᴸ⁻¹, 1, σᴸ]
end

#+END_SRC

#+HTML: </p>
#+HTML: </details>

#+HTML: </p>
#+HTML: </details>

*** Matrix Product Operators
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/MPO.jl
"""
    MPO{L, T<:Number}

Matrix product operator on L sites. The `i`th tensor in the operator
has indices `[aⁱ⁻¹, aⁱ, σⁱ, σ′ⁱ]` where `(σⁱ, σ′ⁱ)` are the physical
indices and `(aⁱ⁻¹, aⁱ)` are bond indices.

A four site MPS would be diagrammatically represented

    σ¹          σ²          σ³          σ⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•     
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴


Note that `a⁰` and `aᴸ` must be of dimension 1.
"""
struct MPO{L, T<:Number}
    tensors::Vector{Array{T,4}}
end


"""
    MPO(W::Array{T,4}, L)
Create an `MPO` for `L` sites with all interior sites containing the tensor
`W`. The tensor is assumed to have the usual matrix-of-operators structure,
with the first two indices being the bond (matrix) dimension and the last two
indices being the physical (operator) dimension. The first and last sites only
use the last row and first column of `W`, respectively.

For example, the MPO form of the Hamiltonian for the TFIM is
constructed as with coupling `g` and length `L` is constructed as
follows:

    id = [1 0
          0 1]

    σᶻ = [1  0 
          0 -1]

    σˣ = [0 1
          1 0]

    σʸ = [0  -im
          im   0]

    W = zeros(3, 3, 2, 2)
    W[1, 1, :, :] = id
    W[2, 1, :, :] = σᶻ
    W[3, 1, :, :] = -g*σˣ
    W[3, 2, :, :] = -σᶻ
    W[3, 3, :, :] = id

returning 
 
    Ĥ::MPO = Ŵ¹ Ŵ² Ŵ³ ⋅⋅⋅ Ŵᴸ⁻¹ Wᴸ
"""
function MPO(W::Array{T,4}, L) where {T}
    L >= 2 || throw(DomainError(L, "At least 2 sites."))

    tensors = Vector{Array{T,4}}(undef, L)
    
    tensors[1] = W[end:end, :, :, :] # Row vector.
    for i in 2:(L-1)
        tensors[i] = W # Matrix
    end
    tensors[L] = W[:, 1:1, :, :] # Column vector.

    MPO{L,T}(tensors)
end

Base.:(==)(O::MPO, U::MPO) = O.tensors == U.tensors
Base.:(≈)(O::MPO, U::MPO)  = O.tensors ≈ U.tensors
Base.getindex(O::MPO, args...) = getindex(O.tensors, args...)
#+END_SRC 

#+HTML: <details><summary>MPO Contraction</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/contraction.jl
"""
    Base.:(*)(O::MPO, ψ::MPS)
representing

    σ¹          σ²          σ³          σ⁴
    |           |           |           | 
    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•     
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴
    σ′¹         σ′²         σ′³         σ′⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•     
"""
function Base.:(*)(O::MPO{L, T}, ψ::MPS{L, T}) where {L, T}
    tensors = Array{T,3}[]
    for i in 1:L
        W = O.tensors[i]
        M = ψ.tensors[i]

        @reduce N[(bᵢ₋₁, aᵢ₋₁), (bᵢ, aᵢ), σᵢ] :=  sum(σ′ᵢ) W[bᵢ₋₁, bᵢ, σᵢ, σ′ᵢ] * M[aᵢ₋₁, aᵢ, σ′ᵢ]
        
        push!(tensors, N)
    end
    MPS{L, T}(tensors)
end


"""
    Base.:(*)(O1::MPO, O2::MPO)
representing

    σ¹          σ²          σ³          σ⁴
    |           |           |           | 
    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•     
    |           |           |           | 
    σ′′¹        σ′′²        σ′′³        σ′′⁴
    σ′′¹        σ′′²        σ′′³        σ′′⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--• 
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴    
"""
function Base.:(*)(O1::MPO{L, T}, O2::MPO{L, T}) where {L, T}
    tensors = Array{T,4}[]
    for i in 1:L
        W1 = O1.tensors[i]
        W2 = O2.tensors[i]

        @reduce V[(bᵢ₋₁, aᵢ₋₁), (bᵢ, aᵢ), σᵢ, σ′ᵢ] :=  sum(σ′′ᵢ) W1[bᵢ₋₁, bᵢ, σᵢ, σ′′ᵢ] * W2[aᵢ₋₁, aᵢ, σ′′ᵢ, σ′ᵢ]
        
        push!(tensors, V)
    end
    MPO{L, T}(tensors)
end

"""
    Base.:(*)(ψ::Adjoint{T,MPS{L,T}}, O::MPO) where {L,T}
representing

    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•       
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴
    σ′¹         σ′²         σ′³         σ′⁴
    |           |           |           | 
    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•
    |           |           |           | 
    σ¹          σ²          σ³          σ⁴ 
"""
function Base.:(*)(ψ′::Adjoint{T,MPS{L,T}}, O::MPO{L, T}) where {L,T}
    ψ = ψ′.parent
    tensors = Array{T,3}[]
    Ws = dg.(reverse(O.tensors))
    for i in 1:L
        W = Ws[i]
        M = ψ.tensors[i]

        @reduce N[(bᵢ₋₁, aᵢ₋₁), (bᵢ, aᵢ), σᵢ] :=  sum(σ′ᵢ) W[bᵢ₋₁, bᵢ, σᵢ, σ′ᵢ] * M[aᵢ₋₁, aᵢ, σ′ᵢ]
        push!(tensors, N)
    end
    adjoint(MPS{L, T}(tensors))
end
#+END_SRC 
#+HTML: </p>
#+HTML: </details>

#+HTML: </p>
#+HTML: </details>

*** Compression
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/compression.jl
abstract type Direction end
struct Left  <: Direction end
struct Right <: Direction end
const left  = Left()
const right = Right()

function compress(ψ::MPS{L, T}, to_the::Right; Dcut::Int=typemax(Int)) where {L, T}
    tensors = Array{T, 3}[]
    
    B = ψ[1]
    d = length(B[1, 1, :])
    
    @cast Bm[(σ¹, a⁰), a¹] |= B[a⁰, a¹, σ¹]
    U, S, V = psvd(Bm, rank=Dcut)
    #S = S/√sum(S .^ 2)

    @cast A[a⁰, a¹, σ¹] |= U[(σ¹, a⁰), a¹] (σ¹:d)
    push!(tensors, A)
    
    for i ∈ 2:L
        B = ψ[i]
        d = length(B[1, 1, :])

        @tensor M[aⁱ⁻¹, aⁱ, σⁱ]    := (Diagonal(S)*V')[aⁱ⁻¹, aⁱ⁻¹′] * B[aⁱ⁻¹′, aⁱ, σⁱ]

        @cast   Mm[(σⁱ, aⁱ⁻¹), aⁱ] |= M[aⁱ⁻¹, aⁱ, σⁱ]
        
        U, S, V = psvd(Mm, rank=Dcut)
        #S = S/√sum(S .^ 2)

        @cast A[aⁱ⁻¹, aⁱ, σⁱ] |= U[(σⁱ, aⁱ⁻¹), aⁱ] (σⁱ:d)
        push!(tensors, A)
    end
    MPS{L, T}(tensors), Left()
end

leftcanonical(ψ) = compress(ψ, right)[1]

function compress(ψ::MPS{L, T}, to_the::Left; Dcut::Int=typemax(Int)) where {L, T}
    tensors = Array{T, 3}[]
    
    A = ψ[L]
    d = length(A[1, 1, :])
    @cast Am[aᴸ⁻¹, (σᴸ, aᴸ)] |= A[aᴸ⁻¹, aᴸ, σᴸ]
    
    U, S, V = psvd(Am, rank=Dcut)
    #S = S/√sum(S .^ 2)    

    @cast B[aᴸ⁻¹, aᴸ, σᴸ] |= V'[aᴸ⁻¹, (σᴸ, aᴸ)] (σᴸ:d)
    push!(tensors, B)
    
    for i ∈ (L-1):-1:1
        A = ψ[i]
        d = length(A[1, 1, :])
        @tensor M[aⁱ⁻¹, aⁱ, σⁱ]    := A[aⁱ⁻¹, aⁱ′, σⁱ] * (U * Diagonal(S))[aⁱ′, aⁱ]
        @cast   Mm[aⁱ⁻¹, (σⁱ, aⁱ)] |= M[aⁱ⁻¹, aⁱ, σⁱ]
        
        U, S, V = psvd(Mm, rank=Dcut)
        #S = S/√sum(S .^ 2)

        @cast B[aⁱ⁻¹, aⁱ, σⁱ] |= V'[aⁱ⁻¹, (σⁱ, aⁱ)] (σⁱ:d)
        push!(tensors, B)
    end
    MPS{L, T}(reverse(tensors)), Right()
end

rightcanonical(ψ) = compress(ψ, left)[1]

compress(ψ; Dcut) = compress(ψ, left, Dcut=Dcut)[1]

#+END_SRC 
#+HTML: </p>
#+HTML: </details>

*** Imaginary Time Evolution
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/timeevolution.jl
#---------------------------------------------------------------------
# Imaginary Time Evolution Assuming only nearest neighbor interactions

"""
     MPO_odd_time_evolver(h1::Matrix{T}, hi::Matrix{T}, hL::Matrix{T}, τ, L) where {T}
"""
function _MPO_handed_time_evolver(hs::Vector{Matrix{T}}, τ, L, d) where {T}
    tensors = Array{T, 4}[]
    for h in hs
        O = exp(-τ*h)
        @cast P[(σⁱ, σⁱ′), (σⁱ⁺¹, σⁱ⁺¹′)] |= O[(σⁱ, σⁱ⁺¹), (σⁱ′, σⁱ⁺¹′)] (σⁱ:d, σⁱ′:d)
        U, S, V = svd(P)

        @cast U[1, k, σⁱ, σⁱ′]     := U[(σⁱ, σⁱ′), k] * √(S[k])      (σⁱ:d)
        @cast Ū[k, 1, σⁱ⁺¹, σⁱ⁺¹′] := √(S[k]) * V'[k, (σⁱ⁺¹, σⁱ⁺¹′)] (σⁱ⁺¹:d)
        push!(tensors, U, Ū)
    end
    MPO{L, T}(tensors)
end


"""

"""
function MPO_time_evolvers(h1::Matrix, hi::Matrix, hL::Matrix, τ, L, d)
    if iseven(L)
        odd_hs  = [h1, [hi for _ in 3:2:(L-1)]...]
        even_hs = [[hi for i in 2:2:(L-1)]..., hL]
    else
        odd_hs  = [h1, [hi for _ in 3:2:(L-1)]..., hL]
        even_hs = [hi for i in 2:2:(L-1)]
    end
    
    Uodd  = _MPO_handed_time_evolver(odd_hs, τ, L, d)
    Ueven = _MPO_handed_time_evolver(even_hs, τ, L, d)
    Uodd, Ueven
end

function imag_time_evolution(ψ::MPS{L, T}, h1::Matrix{T}, hi::Matrix{T}, hL::Matrix{T}, 
                             β, N, Dcut) where {L, T}
    τ = β/N
    d = length(ψ[1][1, 1, :])
    ϕ = ψ  # Ground state guess
    dir = left
    Uodd, Ueven = MPO_time_evolvers(h1, hi, hL, τ, L, d)
    for _ in 1:N
        ϕ1, dir = compress(Uodd  * ϕ,  dir, Dcut=Dcut)
        ϕ,  dir = compress(Ueven * ϕ1, dir, Dcut=Dcut)
        #ϕ,  dir = compress(Uodd  * ϕ2, dir, Dcut=Dcut)
    end
    ϕ
end
#+END_SRC
#+HTML: </details>
#+HTML: </p>

*** Iterative Ground State Search
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/groundstate.jl

function R_exprs(ψ::MPS{L, T}, H::MPO{L, T}) where {L, T}
    Rs = Array{T, 3}[]
    B = ψ[L]
    W = H[L]
    @reduce R[bᴸ⁻¹, aᴸ⁻¹, aᴸ⁻¹′] := sum(σᴸ, σᴸ′, bᴸ, aᴸ,  aᴸ′) begin 
        (conj.(B))[aᴸ⁻¹, aᴸ, σᴸ] * W[bᴸ⁻¹, bᴸ, σᴸ, σᴸ′] * B[aᴸ⁻¹′, aᴸ′, σᴸ′]
    end
    push!(Rs, R)
    for i in (L-1):-1:2
        B = ψ[i]
        W = H[i]
        @reduce R[bⁱ⁻¹, aⁱ⁻¹, aⁱ⁻¹′] := sum(σⁱ, σⁱ′, bⁱ, aⁱ,  aⁱ′) begin 
            (conj.(B))[aⁱ⁻¹,aⁱ,σⁱ] * W[bⁱ⁻¹,bⁱ,σⁱ,σⁱ′] * B[aⁱ⁻¹′,aⁱ′,σⁱ′] * R[bⁱ,aⁱ,aⁱ′]
        end
        push!(Rs, R)
    end
    reverse(Rs)
end

function sweep!(::Right, ψ::MPS{L, T}, H::MPO{L, T}, R_exs, Dcut) where {L, T}
    L_exs = Array{T, 3}[]
    L_ex  = ones(T, 1, 1, 1)
    for l in 1:(L-1)
        M    = ψ[l]
        Dˡ⁻¹, Dˡ, d = size(M)
        W    = H[l]
        R_ex = R_exs[l]
        @cast  v[(σˡ, aˡ⁻¹, aˡ)] |= M[aˡ⁻¹, aˡ, σˡ]

        @reduce h[(σˡ, aˡ⁻¹, aˡ), (σˡ′, aˡ⁻¹′, aˡ′)] |= sum(bˡ⁻¹, bˡ) begin
            L_ex[bˡ⁻¹, aˡ⁻¹, aˡ⁻¹′] * W[bˡ⁻¹, bˡ, σˡ, σˡ′] * R_ex[bˡ, aˡ, aˡ′]
        end

        λ, Φ = eigs(h, v0=v, nev=1, which=:SR)
        E = λ[1]
        v⁰ = Φ[:,1]

        @cast Mm[(σˡ, aˡ⁻¹), aˡ] |= v⁰[(σˡ, aˡ⁻¹, aˡ)] (aˡ⁻¹:Dˡ⁻¹, aˡ:Dˡ, σˡ:d)
        U, S, V = psvd(Mm, rank=Dcut)
        @cast A[aˡ⁻¹, aˡ, σˡ] |= U[(σˡ, aˡ⁻¹), aˡ] (σˡ:d)

        @reduce L_ex[bˡ, aˡ, aˡ′] := sum(σˡ, σˡ′, bˡ⁻¹, aˡ⁻¹, aˡ⁻¹′) begin
            L_ex[bˡ⁻¹,aˡ⁻¹,aˡ⁻¹′] * (conj.(A))[aˡ⁻¹,aˡ,σˡ] * W[bˡ⁻¹,bˡ,σˡ,σˡ′] * A[aˡ⁻¹′,aˡ′,σˡ′]
        end
        push!(L_exs, L_ex)

        SVp = Diagonal(S)*(V')
        Bp1 = ψ.tensors[l+1]
        @tensor Mp1[sⁱ⁻¹, aⁱ, σⁱ] := SVp[sⁱ⁻¹, aⁱ⁻¹] * Bp1[aⁱ⁻¹, aⁱ, σⁱ]
        ψ.tensors[l+1] = Mp1
    end
    return ψ, L_exs
end

# function sweep!(::Right, ψ::MPS{L, T}, H::MPO{L, T}, Rs, Dcut) where {L, T}
#     L_exs = Array{T, 3}[]
#     B = ψ[1]
#     D⁰, D¹, d = size(B)
#     W = H[1]
#     R = Rs[1]
#     @cast v[(σ¹, a⁰, a¹)] |= B[a⁰, a¹, σ¹]
#     @reduce h[(σ¹, a¹), (σ¹′, a¹′)] |= sum(b⁰, b¹) begin
#         W[b⁰, b¹, σ¹, σ¹′] * R[b¹, a¹, a¹′]
#     end
#     λ⁰, v⁰ = eigs(h, v0=v, nev=1, which=:SR)
#     @cast M[(σ¹, a⁰), a¹] |= v⁰[(σ¹, a⁰, a¹)] (a⁰:D⁰, a¹:D¹, σ¹:d)
#     U, S, V = psvd(M, rank=Dcut)
#     @cast   A[a⁰, a¹, σ¹]  |= U[(σ¹, a⁰), a¹] (σ¹:d)
#     @reduce L_ex[b¹, a¹, a¹′] := sum(σ¹, σ¹′, b⁰, a⁰, a⁰′) begin
#         (conj.(A))[a⁰, a¹, σ¹] * W[b⁰, b¹, σ¹, σ¹′] * A[a⁰′, a¹′, σ¹′]
#     end
#     push!(L_exs, L_ex)
#     ψ.tensors[1] = A # Mutate ψ

#     for l in 2:(L-1)
#         B = ψ[l]
#         W = H[l]
#         R = Rs[l]
#         SVp = Diagonal(S)*V'
#         @reduce M[aⁱ⁻¹, aⁱ, σⁱ]   := sum(aⁱ⁻¹′) SVp[aⁱ⁻¹, aⁱ⁻¹′] * B[aⁱ⁻¹′, aⁱ, σⁱ]
#         @cast   v[(σⁱ, aⁱ⁻¹, aⁱ)] |= M[aⁱ⁻¹, aⁱ, σⁱ]
#         @reduce h[(σˡ, aˡ⁻¹, aˡ), (σˡ′, aˡ⁻¹′, aˡ′)] |= sum(bˡ⁻¹, bˡ) begin
#             L_ex[bˡ⁻¹, aˡ⁻¹, aˡ⁻¹′] * W[bˡ⁻¹, bˡ, σˡ, σˡ′] * R[bˡ, aˡ, aˡ′]
#         end
#         sizem1 = size(M)
#         #println((l=l, sizeB=size(B), sizeM=size(M), sizeR=size(R), sizeRp1=size(Rs[l-1])))
        
#         λ⁰, v⁰ = eigs(h, v0=v, nev=1, which=:SR)
#         Dˡ⁻¹, Dˡ, d = size(M)       
#         @cast M[aˡ⁻¹, aˡ, σˡ]    |= v⁰[(σˡ, aˡ⁻¹, aˡ)] (aˡ⁻¹:Dˡ⁻¹, aˡ:Dˡ, σˡ:d)
#         @cast Mm[(σˡ, aˡ⁻¹), aˡ] |= M[aˡ⁻¹, aˡ, σˡ]

#         U, S, V = psvd(Mm, rank=Dcut)
#         #@cast A[aⁱ⁻¹, aⁱ, σⁱ] |= U[(σⁱ, aⁱ⁻¹), aⁱ] (σⁱ:d)
#         @cast A[aˡ⁻¹, aˡ, σˡ] |= U[(σˡ, aˡ⁻¹), aˡ] (σˡ:d)
#         println((sizeB =size(B), sizem1=sizem1, sizem2=size(M), sizeA=size(A), sizeU=size(U)))
#         @reduce L_ex[bˡ, aˡ, aˡ′] := sum(σˡ, σˡ′, bˡ⁻¹, aˡ⁻¹,  aˡ⁻¹′) begin
#             L_ex[bˡ⁻¹,aˡ⁻¹,aˡ⁻¹′] * (conj.(A))[aˡ⁻¹,aˡ,σˡ] * W[bˡ⁻¹,bˡ,σˡ,σˡ′] * A[aˡ⁻¹′,aˡ′,σˡ′]
#         end
#         push!(L_exs, L_ex)
#         ψ.tensors[l] = A
#     end
#     B = ψ.tensors[L]
#     @reduce M[aᴸ⁻¹, aᴸ, σᴸ] := sum(aᴸ⁻¹′) (Diagonal(S)*V')[aᴸ⁻¹, aᴸ⁻¹′] * B[aᴸ⁻¹′, aᴸ, σᴸ]
#     ψ.tensors[L] = M
#     ψ, L_exs, λ⁰[1]
# end

function sweep!(::Left, ψ::MPS{L, T}, H::MPO{L, T}, L_exs, Dcut) where {L, T}
    R_exs = Array{T, 3}[]
    A = ψ[L]
    Dᴸ⁻¹, Dᴸ, d = size(A)
    W = H[L]
    L_ex = L_exs[L-1]
    @cast v[(σᴸ, aᴸ⁻¹, aᴸ)] |= A[aᴸ⁻¹, aᴸ, σᴸ]
    @reduce h[(σᴸ, aᴸ⁻¹), (σᴸ′, aᴸ⁻¹′)] |= sum(bᴸ⁻¹, bᴸ) begin
        L_ex[bᴸ⁻¹, aᴸ⁻¹, aᴸ⁻¹′] * W[bᴸ⁻¹, bᴸ, σᴸ, σᴸ′]
    end
    λ⁰, v⁰ = eigs(h, v0=v, nev=1, which=:SR)
    @cast M[aᴸ⁻¹, (σᴸ, aᴸ)] |= v⁰[(σᴸ, aᴸ⁻¹, aᴸ)] (aᴸ⁻¹:Dᴸ⁻¹, aᴸ:Dᴸ, σᴸ:d)

    U, S, V = psvd(M, rank=Dcut)

    @cast B[aᴸ⁻¹, aᴸ, σᴸ] |= V'[aᴸ⁻¹, (σᴸ, aᴸ)] (σᴸ:d)

    @reduce R_ex[bᴸ⁻¹, aᴸ⁻¹, aᴸ⁻¹′] := sum(σᴸ, σᴸ′, bᴸ, aᴸ,  aᴸ′) begin 
        (conj.(B))[aᴸ⁻¹, aᴸ, σᴸ] * W[bᴸ⁻¹, bᴸ, σᴸ, σᴸ′] * B[aᴸ⁻¹′, aᴸ′, σᴸ′]
    end
    push!(R_exs, R_ex)
    for l in (L-1):-1:2
        A = ψ[l]
        Dᴸ⁻¹, Dᴸ, d = size(A)
        W = H[l]
        L_ex = L_exs[l-1]
        US = U * Diagonal(S)
        @reduce M[aˡ⁻¹, aˡ, σˡ]   := sum(aˡ′) A[aˡ⁻¹, aˡ′, σˡ] * US[aˡ′, aˡ]
        @cast   v[(σˡ, aˡ⁻¹, aˡ)] |= M[aˡ⁻¹, aˡ, σˡ]

        @reduce h[(σˡ, aˡ⁻¹, aˡ), (σˡ′, aˡ⁻¹′, aˡ′)] |= sum(bˡ⁻¹, bˡ) begin
            L_ex[bˡ⁻¹, aˡ⁻¹, aˡ⁻¹′] * W[bˡ⁻¹, bˡ, σˡ, σˡ′] * R_ex[bˡ, aˡ, aˡ′]
        end
        
        λ⁰, v⁰ = eigs(h, v0=v, nev=1, which=:SR)
        Dˡ⁻¹, Dˡ, d = size(M)       
        @cast M[aˡ⁻¹, (σˡ, aˡ)] |= v⁰[(σˡ, aˡ⁻¹, aˡ)] (aˡ⁻¹:Dˡ⁻¹, aˡ:Dˡ, σˡ:d)
        U, S, V = psvd(M, rank=Dcut)

        @cast B[aˡ⁻¹, aˡ, σˡ] |= V'[aˡ⁻¹, (σˡ, aˡ)] (σˡ:d)

        @reduce R_ex[bⁱ⁻¹, aⁱ⁻¹, aⁱ⁻¹′] := sum(σⁱ, σⁱ′, bⁱ, aⁱ,  aⁱ′) begin 
            (conj.(B))[aⁱ⁻¹,aⁱ,σⁱ] * W[bⁱ⁻¹,bⁱ,σⁱ,σⁱ′] * B[aⁱ⁻¹′,aⁱ′,σⁱ′] * R_ex[bⁱ,aⁱ,aⁱ′]
        end
        push!(R_exs, R_ex)
    end
    A = ψ.tensors[1]
    @reduce M[a⁰, a¹, σ¹] := sum(a¹′) A[a⁰, a¹′, σ¹] * (U * Diagonal(S))[a¹′, a¹]
    ψ.tensors[1] = M
    ψ, reverse(R_exs), λ⁰[1]
end

not(x) = ~x

function isconverged(ψ::MPS, H::MPO; ϵ=1e-2)
    ϕ = rightcanonical(ψ)
    realize(ϕ' * (H * H * ϕ) - (ϕ' * (H * ϕ))^2) < ϵ
end

function ground_state(ψ::MPS{L, T}, H::MPO{L, T}, Dcut) where {L, T}
    ψ = ψ |> copy
    R_exs = R_exprs(ψ, H)
    converged = false
    count     = 0
    while not(converged)
        #println(size.(ψ.tensors))
        ψ, L_exs = sweep!(right, ψ, H, R_exs, Dcut)
        #println(size.(ψ.tensors))
        ψ, R_exs, E₀′ = sweep!(left,  ψ, H, L_exs, Dcut)
        #println(size.(ψ.tensors))
        #println(size.(R_exs))

        count += 1
        @show count
        if isconverged(ψ, H)
            converged = true
        elseif count >= 100
            @warn "Did not converge in 200 iterations"
            break
        end
    end
    ψ, E₀′
end

#+END_SRC
#+HTML: </details>
#+HTML: </p>


** Tests
#+HTML:  <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle test/runtests.jl
using Test, MatrixProductStates

@testset "TFIM" begin
    g = 1.0; L = 7

    id = [1.0 0.0; 0.0 1.0]
    σˣ = [0.0 1.0; 1.0 0.0]
    σᶻ = [1.0 0.0; 0.0 -1.0]

    H_tnsr = zeros(3, 3, 2, 2)
    H_tnsr[1, 1, :, :] = id
    H_tnsr[2, 1, :, :] = -σᶻ
    H_tnsr[3, 1, :, :] = -g*σˣ
    H_tnsr[3, 2, :, :] = σᶻ
    H_tnsr[3, 3, :, :] = id
    H = MPO(H_tnsr, L)

    ψ = randn(MPS{L, Float64}, 100, 2)

    @test (ψ' * H) * ψ ≈ ψ' * (H * ψ)
    
    ψ̃ = compress(ψ, left, Dcut=80)[1] # Note: no actual information is lost in this 
                                        # compression because of the small size of the chain

    @test              ψ̃'ψ̃ ≈ 1
    @test          ψ'ψ/ψ'ψ ≈ ψ̃'ψ̃
    @test ((ψ'*(H*ψ))/ψ'ψ) ≈ (ψ̃' * (H * ψ̃))/ψ̃'ψ̃
    @test ((ψ'*(H*ψ))/ψ'ψ) ≈ (ψ̃' * (H * ψ))/ψ̃'ψ
end

#+END_SRC
#+HTML: </details>
#+HTML: </p>
