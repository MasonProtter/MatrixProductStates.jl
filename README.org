* MatrixProductStates.jl

This is a package-in-progress in which I intend to implement a [[https://en.wikipedia.org/wiki/Density_matrix_renormalization_group][DMRG]]
algorithm over matrix product states as explained in Schollwöck's [[https://www.sciencedirect.com/science/article/pii/S0003491610001752][The
density-matrix renormalization group in the age of matrix product
states]]. This same project has been undertaken in [[https://github.com/0/LatticeSweeper.jl][LatticeSweeper.jl]]. 

The code in this repo is currently under development. Many things
do not work and even fewer things are tested. 

** Source Code
This readme is a literal document containing all of the source and
test code for the package.
*** Module Definition
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/MatrixProductStates.jl
module MatrixProductStates

using LinearAlgebra, TensorOperations, TensorCast, LowRankApprox, Arpack, Strided

export *, /, ==, ≈, isequal, adjoint, getindex, randn
export MPS, MPO, left, right, compress, imag_time_evolution, rightcanonical, leftcanonical 
export ground_state

include("MPS.jl")
include("MPO.jl")
include("compression.jl")
include("contraction.jl")
include("timeevolution.jl")
include("groundstate.jl")
include("utils.jl")

end
#+END_SRC
#+HTML: </details>
#+HTML: </p>
*** Matrix Product States
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/MPS.jl
"""
    MPS{L, T<:Number}

Matrix product state on L sites. 

The `i`th tensor in the state has indices `[aⁱ⁻¹, aⁱ, σⁱ]` where
`(aⁱ⁻¹, aⁱ)` are bond indices and `σⁱ` is the physical index.

A four site MPS would be diagrammatically represented

    σ¹          σ²          σ³          σ⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•     

Note that `a⁰` and `aᴸ` must be of dimension 1.
"""
struct MPS{L, T<:Number} 
    tensors::Vector{Array{T,3}}
end

Base.isequal(ψ::MPS, ϕ::MPS)     = (isequal(ψ.tensors, ϕ.tensors))
Base.isapprox(ψ::MPS, ϕ::MPS)   = isapprox(ψ.tensors, ϕ.tensors)

Base.eltype(::Type{MPS{L, T}}) where {L, T} = T

Base.length(::MPS{L, T}) where {L, T} = L

Base.size(::MPS{L, T}) where {L, T} = (L,)
Base.getindex(ψ::MPS, i::Int) = getindex(ψ.tensors, i)

Base.:(*)(ψ::MPS{L, T}, x::Number) where {L, T} = MPS{L,T}(ψ.tensors .* x)
Base.:(*)(x::Number, ψ::MPS) = ψ * x
Base.:(/)(ψ::MPS{L,T}, x::Number) where {L, T} = MPS{L,T}(ψ.tensors ./ x)
Base.copy(ψ::MPS{L, T}) where {L, T} = MPS{L,T}(copy(ψ.tensors))

function Base.randn(::Type{MPS{L, T}}, D::Int, d::Int) where {L, T}
    tensors = [randn(1, D, d), [randn(D, D, d) for _ in 2:(L-1)]..., randn(D, 1, d)]
    MPS{L, T}(tensors) |> leftcanonical |> rightcanonical
end

"""
    MPS(vs::Vector{Vector})
Create an `MPS` representing a product state (all bonds have dimension 1),
where each site is described by the corresponding element of `vs`.
"""
function MPS(vs::Vector{Vector{T}}) where {T}
    L = length(vs)

    tensrs = Vector{Array{T,3}}(undef, L)
    for i in 1:L
        tensrs[i] = reshape(copy(vs[i]), 1, 1, :)
    end

    MPS{L,T}(tensrs)
end

"""
    MPS(v::Vector, L)
Create an `MPS` for `L` sites representing a uniform product state (all bonds
have dimension 1), where each site is described by `v`.
"""
MPS(v::Vector, L) = MPS([v for _ in 1:L])

function Base.show(io::IO, ::MIME"text/plain", ψ::MPS{L, T}) where {L, T}
    d = length(ψ.tensors[2][1, 1, :])
    bonddims = [size(ψ[i][:, :, 1]) for i in 1:L]
    println(io, "Matrix product state on $L sites")
    _show_mps_dims(io, L, d, bonddims)
end

function Base.show(ψ::MPS{L, T}) where {L, T}
    d = length(ψ.tensors[2][1, 1, :])
    bonddims = [size(ψ[i][:, :, 1]) for i in 1:L]
    println("Matrix product state on $L sites")
    _show_mps_dims(L, d, bonddims)
end

function _show_mps_dims(io::IO, L, d, bonddims)
    println(io, "  Physical dimension: $d")
    print(io, "  Bond dimensions:   ")
    if L > 8
        for i in 1:8
            print(io, bonddims[i], " × ")
        end
        print(io, " ... × ", bonddims[L])
    else
        for i in 1:(L-1)
            print(io, bonddims[i], " × ")
        end
        print(io, bonddims[L])
    end
end

function Base.show(io::IO, ψ::MPS{L, T}) where {L, T}
    print(io, "MPO on $L sites")
end

#+END_SRC

#+HTML: <details><summary>Adjoint MPS</summary>
#+HTML: <p>

#+BEGIN_SRC julia :comments both :tangle src/MPS.jl
function Base.adjoint(ψ::MPS{L, T}) where {L,T}
    Adjoint{T, MPS{L, T}}(ψ)
end

function Base.show(io::IO, ::MIME"text/plain", ψ::Adjoint{T, MPS{L, T}}) where {L, T}
    d = length(ψ.parent[2][1, 1, :])
    bonddims = reverse([reverse(size(ψ.parent[i][:, :, 1])) for i in 1:L])
    println(io, "Adjoint matrix product state on $L sites")
    _show_mps_dims(io, L, d, bonddims)
end

function Base.show(io::IO, ψ::Adjoint{T, MPS{L, T}}) where {L, T}
    print(io, "Adjoint MPO on $L sites")t
end

Base.size(::Adjoint{T, MPS{L, T}}) where {L, T} = (1, L)

function Base.getindex(ψ::Adjoint{T, MPS{L, T}}, args...) where {L, T}
    out = getindex(reverse(ψ.parent.tensors), args...)
    permutedims(conj.(out), (2, 1, 3))
end

adjoint_tensors(ψ::MPS) = reverse(conj.(permutedims.(ψ.tensors, [(2, 1, 3)])))
#+END_SRC

#+HTML: </p>
#+HTML: </details>

#+HTML: <details><summary>MPS Contraction</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/contraction.jl

"""
    Base.:(*)(ψ′::Adjoint{T, MPS{L, T}}, ϕ::MPS{L, T}) where {L, T}
representing
    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•       
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴
    σ′¹         σ′²         σ′³         σ′⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•
"""
function Base.:(*)(ψ′::Adjoint{T, MPS{L, T}}, ϕ::MPS{L, T}) where {L, T}
    ψ = ψ′.parent

    M   = ϕ.tensors[1]
    M̃dg = dg(ψ.tensors[1])
    
    @tensor cont[b₁, a₁] := M̃dg[b₁, 1, σ₁] * M[1, a₁, σ₁]
    
    for i in 2:L-1
        M   = ϕ.tensors[i]
        M̃dg = dg(ψ.tensors[i])

        @tensor cont[bᵢ, aᵢ] := M̃dg[bᵢ, bᵢ₋₁, σᵢ] * cont[bᵢ₋₁, aᵢ₋₁] * M[aᵢ₋₁, aᵢ, σᵢ]
    end
    M   = ϕ.tensors[L]
    M̃dg = dg(ψ.tensors[L])
    
    @tensor M̃dg[1, bᴸ⁻¹, σᴸ] * cont[bᴸ⁻¹, aᴸ⁻¹] * M[aᴸ⁻¹, 1, σᴸ]
end

#+END_SRC

#+HTML: </p>
#+HTML: </details>

#+HTML: </p>
#+HTML: </details>

*** Matrix Product Operators
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/MPO.jl
"""
    MPO{L, T<:Number}

Matrix product operator on L sites. The `i`th tensor in the operator
has indices `[aⁱ⁻¹, aⁱ, σⁱ, σ′ⁱ]` where `(σⁱ, σ′ⁱ)` are the physical
indices and `(aⁱ⁻¹, aⁱ)` are bond indices.

A four site MPS would be diagrammatically represented

    σ¹          σ²          σ³          σ⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•     
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴


Note that `a⁰` and `aᴸ` must be of dimension 1.
"""
struct MPO{L, T<:Number}
    tensors::Vector{Array{T,4}}
end


"""
    MPO(W::Array{T,4}, L)
Create an `MPO` for `L` sites with all interior sites containing the tensor
`W`. The tensor is assumed to have the usual matrix-of-operators structure,
with the first two indices being the bond (matrix) dimension and the last two
indices being the physical (operator) dimension. The first and last sites only
use the last row and first column of `W`, respectively.

For example, the MPO form of the Hamiltonian for the TFIM is
constructed as with coupling `g` and length `L` is constructed as
follows:

    id = [1 0
          0 1]

    σᶻ = [1  0 
          0 -1]

    σˣ = [0 1
          1 0]

    σʸ = [0  -im
          im   0]

    W = zeros(3, 3, 2, 2)
    W[1, 1, :, :] = id
    W[2, 1, :, :] = σᶻ
    W[3, 1, :, :] = -g*σˣ
    W[3, 2, :, :] = -σᶻ
    W[3, 3, :, :] = id

returning 
 
    Ĥ::MPO = Ŵ¹ Ŵ² Ŵ³ ⋅⋅⋅ Ŵᴸ⁻¹ Wᴸ
"""
function MPO(W::Array{T,4}, L) where {T}
    L >= 2 || throw(DomainError(L, "At least 2 sites."))

    tensors = Vector{Array{T,4}}(undef, L)
    
    tensors[1] = W[end:end, :, :, :] # Row vector.
    for i in 2:(L-1)
        tensors[i] = W # Matrix
    end
    tensors[L] = W[:, 1:1, :, :] # Column vector.

    MPO{L,T}(tensors)
end

Base.:(==)(O::MPO, U::MPO) = O.tensors == U.tensors
Base.:(≈)(O::MPO, U::MPO)  = O.tensors ≈ U.tensors
Base.getindex(O::MPO, args...) = getindex(O.tensors, args...)
#+END_SRC 

#+HTML: <details><summary>MPO Contraction</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/contraction.jl
"""
    Base.:(*)(O::MPO, ψ::MPS)
representing

    σ¹          σ²          σ³          σ⁴
    |           |           |           | 
    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•     
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴
    σ′¹         σ′²         σ′³         σ′⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•     
"""
function Base.:(*)(O::MPO{L, T}, ψ::MPS{L, T}) where {L, T}
    tensors = Array{T,3}[]
    for i in 1:L
        W = O.tensors[i]
        M = ψ.tensors[i]

        @reduce N[(bᵢ₋₁, aᵢ₋₁), (bᵢ, aᵢ), σᵢ] :=  sum(σ′ᵢ) W[bᵢ₋₁, bᵢ, σᵢ, σ′ᵢ] * M[aᵢ₋₁, aᵢ, σ′ᵢ]
        
        push!(tensors, N)
    end
    MPS{L, T}(tensors)
end


"""
    Base.:(*)(O1::MPO, O2::MPO)
representing

    σ¹          σ²          σ³          σ⁴
    |           |           |           | 
    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•     
    |           |           |           | 
    σ′′¹        σ′′²        σ′′³        σ′′⁴
    σ′′¹        σ′′²        σ′′³        σ′′⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--• 
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴    
"""
function Base.:(*)(O1::MPO{L, T}, O2::MPO{L, T}) where {L, T}
    tensors = Array{T,4}[]
    for i in 1:L
        W1 = O1.tensors[i]
        W2 = O2.tensors[i]

        @reduce V[(bᵢ₋₁, aᵢ₋₁), (bᵢ, aᵢ), σᵢ, σ′ᵢ] :=  sum(σ′′ᵢ) W1[bᵢ₋₁, bᵢ, σᵢ, σ′′ᵢ] * W2[aᵢ₋₁, aᵢ, σ′′ᵢ, σ′ᵢ]
        
        push!(tensors, V)
    end
    MPO{L, T}(tensors)
end

"""
    Base.:(*)(ψ::Adjoint{T,MPS{L,T}}, O::MPO) where {L,T}
representing

    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•       
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴
    σ′¹         σ′²         σ′³         σ′⁴
    |           |           |           | 
    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•
    |           |           |           | 
    σ¹          σ²          σ³          σ⁴ 
"""
function Base.:(*)(ψ′::Adjoint{T,MPS{L,T}}, O::MPO{L, T}) where {L,T}
    ψ = ψ′.parent
    tensors = Array{T,3}[]
    Ws = dg.(reverse(O.tensors))
    for i in 1:L
        W = Ws[i]
        M = ψ.tensors[i]

        @reduce N[(bᵢ₋₁, aᵢ₋₁), (bᵢ, aᵢ), σᵢ] :=  sum(σ′ᵢ) W[bᵢ₋₁, bᵢ, σᵢ, σ′ᵢ] * M[aᵢ₋₁, aᵢ, σ′ᵢ]
        push!(tensors, N)
    end
    adjoint(MPS{L, T}(tensors))
end
#+END_SRC 
#+HTML: </p>
#+HTML: </details>

#+HTML: </p>
#+HTML: </details>

*** Compression
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/compression.jl
abstract type Direction end
struct Left  <: Direction end
struct Right <: Direction end
const left  = Left()
const right = Right()

function compress(ψ::MPS{L, T}, to_the::Right; Dcut::Int=typemax(Int)) where {L, T}
    tensors = Array{T, 3}[]
    
    B = ψ[1]
    d = length(B[1, 1, :])
    
    @cast Bm[(σ¹, a⁰), a¹] |= B[a⁰, a¹, σ¹]
    U, S, V = psvd(Bm, rank=Dcut)
    #S = S/√sum(S .^ 2)

    @cast A[a⁰, a¹, σ¹] |= U[(σ¹, a⁰), a¹] (σ¹:d)
    push!(tensors, A)
    
    for i ∈ 2:L
        B = ψ[i]
        d = length(B[1, 1, :])

        @tensor M[aⁱ⁻¹, aⁱ, σⁱ] := (Diagonal(S)*V')[aⁱ⁻¹, aⁱ⁻¹′] * B[aⁱ⁻¹′, aⁱ, σⁱ]
        @cast   Mm[(σⁱ, aⁱ⁻¹), aⁱ] |= M[aⁱ⁻¹, aⁱ, σⁱ]
        
        U, S, V = psvd(Mm, rank=Dcut)
        #S = S/√sum(S .^ 2)

        @cast A[aⁱ⁻¹, aⁱ, σⁱ] |= U[(σⁱ, aⁱ⁻¹), aⁱ] (σⁱ:d)
        push!(tensors, A)
    end
    MPS{L, T}(tensors), Left()
end

leftcanonical(ψ) = compress(ψ, right)[1]

function compress(ψ::MPS{L, T}, to_the::Left; Dcut::Int=typemax(Int)) where {L, T}
    tensors = Array{T, 3}[]
    
    A = ψ[L]
    d = length(A[1, 1, :])
    @cast Am[aᴸ⁻¹, (σᴸ, aᴸ)] |= A[aᴸ⁻¹, aᴸ, σᴸ]
    
    U, S, V = psvd(Am, rank=Dcut)
    #S = S/√sum(S .^ 2)    

    @cast B[aᴸ⁻¹, aᴸ, σᴸ] |= V'[aᴸ⁻¹, (σᴸ, aᴸ)] (σᴸ:d)
    push!(tensors, B)
    
    for i ∈ (L-1):-1:1
        A = ψ[i]
        d = length(A[1, 1, :])
        @tensor M[aⁱ⁻¹, aⁱ, σⁱ]    := A[aⁱ⁻¹, aⁱ′, σⁱ] * (U * Diagonal(S))[aⁱ′, aⁱ]
        @cast   Mm[aⁱ⁻¹, (σⁱ, aⁱ)] |= M[aⁱ⁻¹, aⁱ, σⁱ]
        
        U, S, V = psvd(Mm, rank=Dcut)
        #S = S/√sum(S .^ 2)

        @cast B[aⁱ⁻¹, aⁱ, σⁱ] |= V'[aⁱ⁻¹, (σⁱ, aⁱ)] (σⁱ:d)
        push!(tensors, B)
    end
    MPS{L, T}(reverse(tensors)), Right()
end

rightcanonical(ψ) = compress(ψ, left)[1]

compress(ψ; Dcut) = compress(ψ, left, Dcut=Dcut)[1]

#+END_SRC 
#+HTML: </p>
#+HTML: </details>

*** Imaginary Time Evolution
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/timeevolution.jl
"""
     MPO_odd_time_evolver(h1::Matrix{T}, hi::Matrix{T}, hL::Matrix{T}, τ, L) where {T}
"""
function _MPO_handed_time_evolver(hs::Vector{Matrix{T}}, τ, L, d) where {T}
    tensors = Array{T, 4}[]
    for h in hs
        O = exp(-τ*h)
        @cast P[(σⁱ, σⁱ′), (σⁱ⁺¹, σⁱ⁺¹′)] |= O[(σⁱ, σⁱ⁺¹), (σⁱ′, σⁱ⁺¹′)] (σⁱ:d, σⁱ′:d)
        U, S, V = svd(P)

        @cast U[1, k, σⁱ, σⁱ′]     := U[(σⁱ, σⁱ′), k] * √(S[k])      (σⁱ:d)
        @cast Ū[k, 1, σⁱ⁺¹, σⁱ⁺¹′] := √(S[k]) * V'[k, (σⁱ⁺¹, σⁱ⁺¹′)] (σⁱ⁺¹:d)
        push!(tensors, U, Ū)
    end
    MPO{L, T}(tensors)
end

"""

"""
function MPO_time_evolvers(h1::Matrix, hi::Matrix, hL::Matrix, τ, L, d)
    if iseven(L)
        odd_hs  = [h1, [hi for _ in 3:2:(L-1)]...]
        even_hs = [[hi for i in 2:2:(L-1)]..., hL]
    else
        odd_hs  = [h1, [hi for _ in 3:2:(L-1)]..., hL]
        even_hs = [hi for i in 2:2:(L-1)]
    end
    
    Uodd  = _MPO_handed_time_evolver(odd_hs, τ, L, d)
    Ueven = _MPO_handed_time_evolver(even_hs, τ, L, d)
    Uodd, Ueven
end

function imag_time_evolution(ψ::MPS{L, T}, h1::Matrix{T}, hi::Matrix{T}, hL::Matrix{T}, 
                             β, N, Dcut) where {L, T}
    τ = β/N
    d = length(ψ[1][1, 1, :])
    ϕ = ψ  # Ground state guess
    dir = left
    Uodd, Ueven = MPO_time_evolvers(h1, hi, hL, τ, L, d)
    for _ in 1:N
        ϕ1, dir = compress(Uodd  * ϕ,  dir, Dcut=Dcut)
        ϕ,  dir = compress(Ueven * ϕ1, dir, Dcut=Dcut)
        #ϕ,  dir = compress(Uodd  * ϕ2, dir, Dcut=Dcut)
    end
    ϕ
end
#+END_SRC
#+HTML: </details>
#+HTML: </p>

*** Iterative Ground State Search
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/groundstate.jl

function R_exprs(ψ::MPS{L, T}, H::MPO{L, T}) where {L, T}
    R_exs = Array{T, 3}[]
    B = ψ[L]
    W = H[L]
    R_ex = ones(T, 1, 1, 1)
    @inbounds for i in L:-1:2
        B = ψ[i]
        W = H[i]
        # @reduce R_ex[bⁱ⁻¹, aⁱ⁻¹, aⁱ⁻¹′] := sum(σⁱ, σⁱ′, bⁱ, aⁱ,  aⁱ′) begin 
        #     (conj.(B))[aⁱ⁻¹,aⁱ,σⁱ] * W[bⁱ⁻¹,bⁱ,σⁱ,σⁱ′] * B[aⁱ⁻¹′,aⁱ′,σⁱ′] * R_ex[bⁱ,aⁱ,aⁱ′]
        # end
        @tensor R_ex[bⁱ⁻¹, aⁱ⁻¹, aⁱ⁻¹′] := (conj.(B))[aⁱ⁻¹,aⁱ,σⁱ] * W[bⁱ⁻¹,bⁱ,σⁱ,σⁱ′] * B[aⁱ⁻¹′,aⁱ′,σⁱ′] * R_ex[bⁱ,aⁱ,aⁱ′]
        push!(R_exs, R_ex)
    end
    reverse(R_exs)
end

function sweep!(::Right, ψ::MPS{L, T}, H::MPO{L, T}, R_exs) where {L, T}
    L_exs = Array{T, 3}[]
    L_ex  = ones(T, 1, 1, 1)
    E = zero(T)
    @inbounds for l in 1:(L-1)
        M    = ψ[l]
        Dˡ⁻¹, Dˡ, d = size(M)
        W    = H[l]
        R_ex = R_exs[l]

        @cast v[(σˡ, aˡ⁻¹, aˡ)] |= M[aˡ⁻¹, aˡ, σˡ]

        @reduce h[(σˡ, aˡ⁻¹, aˡ), (σˡ′, aˡ⁻¹′, aˡ′)] |= sum(bˡ⁻¹, bˡ) begin
            L_ex[bˡ⁻¹, aˡ⁻¹, aˡ⁻¹′] * W[bˡ⁻¹, bˡ, σˡ, σˡ′] * R_ex[bˡ, aˡ, aˡ′]
        end strided
        h = collect(h)

        λ, Φ = eigs(h, v0=v, nev=1, which=:SR)
        E = λ[1] 
        v⁰ = Φ[:,1]

        @cast Mm[(σˡ, aˡ⁻¹), aˡ] := v⁰[(σˡ, aˡ⁻¹, aˡ)] (aˡ⁻¹:Dˡ⁻¹, aˡ:Dˡ, σˡ:d)

        U, S, V = svd(Mm)
        @cast A[aˡ⁻¹, aˡ, σˡ] |= U[(σˡ, aˡ⁻¹), aˡ] (σˡ:d, aˡ⁻¹:Dˡ⁻¹, aˡ:Dˡ)
        @cast A[aˡ⁻¹, aˡ, σˡ] |= U[(σˡ, aˡ⁻¹), aˡ] (σˡ:d, aˡ⁻¹:Dˡ⁻¹, aˡ:Dˡ)

        ψ.tensors[l] = A

        @tensor L_ex[bˡ, aˡ, aˡ′] := L_ex[bˡ⁻¹,aˡ⁻¹,aˡ⁻¹′] * (conj.(A))[aˡ⁻¹,aˡ,σˡ] * W[bˡ⁻¹,bˡ,σˡ,σˡ′] * A[aˡ⁻¹′,aˡ′,σˡ′]
        push!(L_exs, L_ex)

        SVp = Diagonal(S)*(V')
        Bp1 = ψ.tensors[l+1]
        @tensor Mp1[sⁱ⁻¹, aⁱ, σⁱ] := SVp[sⁱ⁻¹, aⁱ⁻¹] * Bp1[aⁱ⁻¹, aⁱ, σⁱ]
        ψ.tensors[l+1] = Mp1
    end
    ψ, L_exs, E
end

function sweep!(::Left, ψ::MPS{L, T}, H::MPO{L, T}, L_exs) where {L, T}
    R_exs = Array{T, 3}[]
    R_ex  = ones(T, 1, 1, 1)
    E = zero(T)
    #@show size.(ψ.tensors)
    @inbounds for l in L:-1:2
        M = ψ[l]
        Dˡ⁻¹, Dˡ, d = size(M)
        W    = H[l]
        L_ex = L_exs[l-1]
        @cast v[(σˡ, aˡ⁻¹, aˡ)] |= M[aˡ⁻¹, aˡ, σˡ]

        @reduce h[(σˡ, aˡ⁻¹, aˡ), (σˡ′, aˡ⁻¹′, aˡ′)] |= sum(bˡ⁻¹, bˡ) begin
            L_ex[bˡ⁻¹, aˡ⁻¹, aˡ⁻¹′] * W[bˡ⁻¹, bˡ, σˡ, σˡ′] * R_ex[bˡ, aˡ, aˡ′]
        end strided

        h = collect(h)

        λ, Φ = eigs(h, v0=v, nev=1, which=:SR)
        E = λ[1] 
        v⁰ = Φ[:,1]
        @cast Mm[aˡ⁻¹, (σˡ, aˡ)] |= v⁰[(σˡ, aˡ⁻¹, aˡ)] (aˡ⁻¹:Dˡ⁻¹, aˡ:Dˡ, σˡ:d)
        U, S, V = svd(Mm)
        @cast B[aˡ⁻¹, aˡ, σˡ] |= V'[aˡ⁻¹, (σˡ, aˡ)] (σˡ:d)

        ψ.tensors[l] = B

        @tensor R_ex[bⁱ⁻¹, aⁱ⁻¹, aⁱ⁻¹′] := (conj.(B))[aⁱ⁻¹,aⁱ,σⁱ] * W[bⁱ⁻¹,bⁱ,σⁱ,σⁱ′] * B[aⁱ⁻¹′,aⁱ′,σⁱ′] * R_ex[bⁱ,aⁱ,aⁱ′]
        push!(R_exs, R_ex)

        US = U * Diagonal(S)
        Am1 = ψ.tensors[l-1]
        #(sizeAm1 = size(Am1), sizeUS=size(US)) |> println
        @reduce Mm1[aˡ⁻², sˡ⁻¹, σˡ⁻¹] := sum(aˡ⁻¹′) Am1[aˡ⁻², aˡ⁻¹′, σˡ⁻¹] * US[aˡ⁻¹′, sˡ⁻¹]
        ψ.tensors[l-1] = Mm1
    end
    ψ, R_exs, E
end

function ground_state(ψ::MPS{L, T}, H::MPO{L, T}; maxiter=40) where {L, T}
    ϕ = ψ |> copy
    R_exs = R_exprs(ψ, H)
    converged = false
    count     = 0
    E₀ = zero(T)
    while not(converged)
        ϕ, L_exs, _ = sweep!(right, ϕ, H, R_exs)
        ϕ, R_exs, E₀ = sweep!(left,  ϕ, H, L_exs)

        count += 1
        #@show count
        if iseigenstate(ϕ, H)
            converged = true
        elseif count >= maxiter
            @warn "Did not converge in $maxiter iterations"
            break
        end
    end
    ϕ, E₀, count
end

#+END_SRC
#+HTML: </details>
#+HTML: </p>

*** Utils
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/utils.jl
export ⊗, realize

A ⊗ B = kron(A, B)

realize(x::Number) = error("Unrecognized numerical type")
realize(x::Real) = x
function realize(x::Complex; ϵ=1e-13)
    abs(imag(x)) < ϵ || error("Non-zero imaginary component")
    real(x)
end

dg(M::Array{T, 4}) where {T} = permutedims(conj.(M), (2, 1, 3, 4))
dg(M::Array{T, 3}) where {T} = permutedims(conj.(M), (2, 1, 3))

not(x) = ~x

function iseigenstate(ψ::MPS, H::MPO; ϵ=1e-5)
    ϕ = rightcanonical(ψ)
    realize(ϕ' * (H * H * ϕ) - (ϕ' * (H * ϕ))^2) < ϵ
end


#+END_SRC
#+HTML: </details>
#+HTML: </p>
** Tests
#+HTML:  <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle test/runtests.jl
using Test, MatrixProductStates

@testset "TFIM" begin
    g = 1.0; L = 7

    id = [1.0 0.0; 0.0 1.0]
    σˣ = [0.0 1.0; 1.0 0.0]
    σᶻ = [1.0 0.0; 0.0 -1.0]

    H_tnsr = zeros(3, 3, 2, 2)
    H_tnsr[1, 1, :, :] = id
    H_tnsr[2, 1, :, :] = -σᶻ
    H_tnsr[3, 1, :, :] = -g*σˣ
    H_tnsr[3, 2, :, :] = σᶻ
    H_tnsr[3, 3, :, :] = id
    H = MPO(H_tnsr, L)

    ψ = randn(MPS{L, Float64}, 100, 2)

    @test (ψ' * H) * ψ ≈ ψ' * (H * ψ)
    
    ψ̃ = compress(ψ, left, Dcut=80)[1] # Note: no actual information is lost in this 
                                        # compression because of the small size of the chain

    @test              ψ̃'ψ̃ ≈ 1
    @test          ψ'ψ/ψ'ψ ≈ ψ̃'ψ̃
    @test ((ψ'*(H*ψ))/ψ'ψ) ≈ (ψ̃' * (H * ψ̃))/ψ̃'ψ̃
    @test ((ψ'*(H*ψ))/ψ'ψ) ≈ (ψ̃' * (H * ψ))/ψ̃'ψ

    

end

#+END_SRC
#+HTML: </details>
#+HTML: </p>
