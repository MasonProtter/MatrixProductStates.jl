* MatrixProductStates.jl

This is a package-in-progress in which I am implementing the [[https://en.wikipedia.org/wiki/Density_matrix_renormalization_group][DMRG]]
algorithm over matrix product states as explained in SchollwÃ¶ck's [[https://www.sciencedirect.com/science/article/pii/S0003491610001752][The
density-matrix renormalization group in the age of matrix product
states]]. A similar project has been undertaken in [[https://github.com/0/LatticeSweeper.jl][LatticeSweeper.jl]].

I'm not longer actively developthing this library, but I think it still has value as an educational resource for those wanting to learn DMRG.
Julia made it possible for me to implement this package using syntax which is very close to the math written in the online literature.

To acquire this package, simply open a ~julia~ repl (obtained from https://julialang.org/downloads/) and type
#+BEGIN_SRC julia
using Pkg; Pkg.add("https://github.com/MasonProtter/MatrixProductStates.jl.git")
#+END_SRC

** Example: Transverse Field Ising Model 
#+HTML: <details><summary>Click me!</summary>
#+HTML: <p>
Suppose we didn't realize the one dimensional transverse field Ising
model was exactly solvable and we wanted to study it with DMRG.

The TFIM Hamiltonian is written
#+BEGIN_SRC 
H = - âˆ‘áµ¢ Ïƒá¶»áµ¢Ïƒá¶»áµ¢â‚Šâ‚ - âˆ‘áµ¢ g ÏƒË£áµ¢ 
#+END_SRC
which in MPO form can be written as
#+BEGIN_SRC 
H = WÂ¹ WÂ² WÂ³... Wá´¸â»Â¹ Wá´¸
                   [ ğŸ™    ğŸ˜    ğŸ˜] [ ğŸ™    ğŸ˜    ğŸ˜]     [ ğŸ™    ğŸ˜    ğŸ˜] [ ğŸ™  ]
  = [-gÏƒË£  Ïƒá¶»   ğŸ™] | -Ïƒá¶»  ğŸ˜    ğŸ˜| | -Ïƒá¶»  ğŸ˜    ğŸ˜| ... | -Ïƒá¶»  ğŸ˜    ğŸ˜| |-Ïƒá¶» |
                   [-gÏƒË£  Ïƒá¶»   ğŸ™] [-gÏƒË£  Ïƒá¶»   ğŸ™]     [-gÏƒË£  Ïƒá¶»  ğŸ™] [-gÏƒË£]
#+END_SRC
We can study this Hamiltonian using MatrixProductStates.jl as follows:

First, make a function for generating the Hamiltonian given a coupling strength ~g = h/J~ and a system length ~L~:
#+BEGIN_SRC julia
using MatrixProductStates

function H_TFIM(g, L)
    id = [1  0; 
          0  1]
    ÏƒË£ = [0  1; 
          1  0]
    Ïƒá¶» = [1  0; 
          0 -1]
    W_tnsr = zeros(Complex{Float64}, 3, 3, 2, 2)
    W_tnsr[1, 1, :, :] = id    
    W_tnsr[2, 1, :, :] = -Ïƒá¶»  
    W_tnsr[3, 1, :, :] = -g*ÏƒË£
    W_tnsr[3, 2, :, :] = Ïƒá¶»   
    W_tnsr[3, 3, :, :] = id   

    return MPO(W_tnsr, L) # MPO will assume that WÂ¹ = W_tnsr[end:end, :, :, :] and Wá´¸ = W_tnsr[:, 1:1, :, :]
end
#+END_SRC

*** Ground State
Suppose we want to know the ground state of this system for
~g=0.8~ and ~L=12~ and we have no idea what the MPS form of the ground
state looks like a-priori.
#+BEGIN_SRC julia
g = 1.1; L = 12;

d    = 2;   # This is the local Hilbert space dimension for each site
Dcut = 100; # This is the maximum bond dimension we'll allow our matrix product state to take

H = H_TFIM(g, L)
Ïˆ = randn(MPS{L, Complex{Float64}}, Dcut, d) # Generate a completely randomized matrix product state

Ï•, Eâ‚€ = ground_state(Ïˆ, H, quiet=true) #Set quiet to false (the deault) to turn off notifications about the algorithm's progress
#+END_SRC
We now have the ground state ~Ï•~, and an estimate of it's energy
eigenvalue ~Eâ‚€~!

Note that 12 sites can be easily studied with far less computational
cost as an exact diagonalization, but I didn't want to suggest doing
something like ~L=50~ right off the bat since that took ~90 minutes on
my machine.

We can make sure that this state's energy matches our estimate:
#+BEGIN_SRC julia
julia> Ï•' * H * Ï• â‰ˆ Eâ‚€ # computing âŸ¨Ï•|H|Ï•âŸ©
true
#+END_SRC
and we can varify that it's approximately an eigenstate:
#+BEGIN_SRC julia
julia> Ï•' * H * H * Ï•  â‰ˆ (Ï•' * H * Ï•)^2 # computing âŸ¨Ï•| H^2 |Ï•âŸ© â‰ˆ (âŸ¨Ï•|H|Ï•âŸ©)^2
true
#+END_SRC


*** Correlators
We can take advantage of the ~two_point_correlator~ function to study spin-spin correlations in the TFIM 
#+BEGIN_SRC julia :exports both
using UnicodePlots

Ïƒá¶» = [1 0 
      0 -1]

zz(i, j) = two_point_correlator(i=>Ïƒá¶», j=>Ïƒá¶», 12)

js = 2:12

zzs = [realize(Ï•'*zz(1, j)*Ï•) for j in js] #realize will convert complex numbers with a small imaginary part to real.

lineplot(js, zzs, canvas=DotCanvas, ylim=[0, 1.01], width=80, height=30, 
         ylabel="âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©", xlabel="lattice site j", title="Spin-Spin Correlation for g = $g")
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE 
                                      Spin-Spin Correlation for g = 1.1
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 
         1.01 â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©      â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚:                                                                               â”‚ 
              â”‚ '.                                                                             â”‚ 
              â”‚   '.                                                                           â”‚ 
              â”‚     '.                                                                         â”‚ 
              â”‚       '.                                                                       â”‚ 
              â”‚         ''.                                                                    â”‚ 
              â”‚            ''..                                                                â”‚ 
              â”‚                ''...                                                           â”‚ 
              â”‚                     ''....                                                     â”‚ 
              â”‚                           ''''....                                             â”‚ 
              â”‚                                   '''''.......                                 â”‚ 
              â”‚                                               '''''''.........                 â”‚ 
              â”‚                                                               '''''''''........â”‚ 
            0 â”‚                                                                                â”‚ 
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 
              2                                                                               12
                                               lattice site j
#+END_EXAMPLE
which shows exponentially decaying correlations in the ground state,
as expected for ~g > 1~. We can also redo our calculation in the
ordered phase:
#+BEGIN_SRC julia  :exports both
g = 0.8;

H = H_TFIM(g, L)

Ï•, Eâ‚’ = ground_state(Ïˆ, H, quiet=true)

ordered_zzs = [realize(Ï•'*zz(1, j)*Ï•) for j in js]

lineplot(js, realize.(ordered_zzs), canvas=DotCanvas, ylim=[0, 1.01], width=80, height=30, 
         ylabel="âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©", xlabel="lattice site j", title="Spin-Spin Correlation for g = $g")
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
                                      Spin-Spin Correlation for g = 0.8
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 
         1.01 â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚.                                                                               â”‚ 
              â”‚ ''.                                                                            â”‚ 
              â”‚    ''..                                                                        â”‚ 
              â”‚        '''....                                                                 â”‚ 
âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©      â”‚               ''''''.........                                                  â”‚ 
              â”‚                              ''''''''''''...........                           â”‚ 
              â”‚                                                     '''''''......              â”‚ 
              â”‚                                                                  '''....       â”‚ 
              â”‚                                                                         '..    â”‚ 
              â”‚                                                                            ''..â”‚ 
              â”‚                                                                               'â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
            0 â”‚                                                                                â”‚ 
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 
              2                                                                               12
                                               lattice site j
#+END_EXAMPLE

#+HTML: </details>
#+HTML: </p>


** Source Code
This readme is a literate document containing all of the source and test code for the package. Check it out, I think it's surprisingly legible. 
The sections Matrix Product States, Matrix Product Operatiors, Compression and Iterative Ground State Search are based directly on the math 
written in SchollwÃ¶ck's review.

*** Module Definition
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/MatrixProductStates.jl
module MatrixProductStates

using LinearAlgebra, TensorOperations, TensorCast, LowRankApprox, Arpack, Strided, SparseArrays
#using ProgressMeter

export *, /, ==, â‰ˆ, isequal, adjoint, getindex, randn
export MPS, MPO, left, right, compress, imag_time_evolution, rightcanonical, leftcanonical 
export ground_state, two_point_correlator, realize

include("utils.jl")
include("MPS.jl")
include("MPO.jl")
include("compression.jl")
include("contraction.jl")
include("groundstate.jl")
include("correlation.jl")
include("timeevolution.jl")

end
#+END_SRC
#+HTML: </details>
#+HTML: </p>
*** Utils
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/utils.jl
export âŠ—, realize

abstract type Direction end

struct Left  <: Direction end # Often useful to dispatch on direction an algorithm is going
struct Right <: Direction end

const left  = Left()
const right = Right()

A âŠ— B = kron(A, B)

realize(x::Number) = error("Unrecognized numerical type")
realize(x::Real) = x
function realize(x::Complex; Ïµ=1e-10)
    abs(imag(x)) < Ïµ || error("Non-zero imaginary component, $(imag(x))")
    real(x)
end

dg(M::Array{T, 4}) where {T} = permutedims(conj.(M), (2, 1, 3, 4))
dg(M::Array{T, 3}) where {T} = permutedims(conj.(M), (2, 1, 3))

not(x) = ~x

#+END_SRC
#+HTML: </details>
#+HTML: </p>
*** Matrix Product States
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/MPS.jl
"""
    MPS{L, T<:Number}

Matrix product state on L sites. 

The `i`th tensor in the state has indices `[aâ±â»Â¹, aâ±, Ïƒâ±]` where
`(aâ±â»Â¹, aâ±)` are bond indices and `Ïƒâ±` is the physical index.

A four site MPS would be diagrammatically represented

    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´
    |           |           |           | 
    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢     

Note that `aâ°` and `aá´¸` must be of dimension 1.
"""
struct MPS{L, T<:Number} 
    tensors::Vector{Array{T,3}}
end

Base.isequal(Ïˆ::MPS, Ï•::MPS)     = (isequal(Ïˆ.tensors, Ï•.tensors))
Base.isapprox(Ïˆ::MPS, Ï•::MPS)   = isapprox(Ïˆ.tensors, Ï•.tensors)

Base.eltype(::Type{MPS{L, T}}) where {L, T} = T

Base.length(::MPS{L, T}) where {L, T} = L

Base.size(::MPS{L, T}) where {L, T} = (L,)
Base.getindex(Ïˆ::MPS, i::Int) = getindex(Ïˆ.tensors, i)

Base.:(*)(Ïˆ::MPS{L, T}, x::Number) where {L, T} = MPS{L,T}(Ïˆ.tensors .* x)
Base.:(*)(x::Number, Ïˆ::MPS) = Ïˆ * x
Base.:(/)(Ïˆ::MPS{L,T}, x::Number) where {L, T} = MPS{L,T}(Ïˆ.tensors ./ x)
Base.copy(Ïˆ::MPS{L, T}) where {L, T} = MPS{L,T}(copy.(Ïˆ.tensors))

function Base.randn(::Type{MPS{L, T}}, D::Int, d::Int) where {L, T}
    tensors = [randn(1, D, d), [randn(D, D, d) for _ in 2:(L-1)]..., randn(D, 1, d)]
    MPS{L, T}(tensors) |> leftcanonical |> rightcanonical
end

"""
    MPS(vs::Vector{Vector})
Create an `MPS` representing a product state (all bonds have dimension 1),
where each site is described by the corresponding element of `vs`.
"""
function MPS(vs::Vector{Vector{T}}) where {T}
    L = length(vs)

    tensrs = Vector{Array{T,3}}(undef, L)
    for i in 1:L
        tensrs[i] = reshape(copy(vs[i]), 1, 1, :)
    end

    MPS{L,T}(tensrs)
end

"""
    MPS(v::Vector, L)
Create an `MPS` for `L` sites representing a uniform product state (all bonds
have dimension 1), where each site is described by `v`.
"""
MPS(v::Vector, L) = MPS([v for _ in 1:L])

function Base.show(io::IO, ::MIME"text/plain", Ïˆ::MPS{L, T}) where {L, T}
    d = length(Ïˆ.tensors[2][1, 1, :])
    bonddims = [size(Ïˆ[i][:, :, 1]) for i in 1:L]
    println(io, "Matrix product state on $L sites")
    _show_mps_dims(io, L, d, bonddims)
end

function Base.show(Ïˆ::MPS{L, T}) where {L, T}
    d = length(Ïˆ.tensors[2][1, 1, :])
    bonddims = [size(Ïˆ[i][:, :, 1]) for i in 1:L]
    println("Matrix product state on $L sites")
    _show_mps_dims(L, d, bonddims)
end

function _show_mps_dims(io::IO, L, d, bonddims)
    println(io, "  Physical dimension: $d")
    print(io, "  Bond dimensions:   ")
    if L > 8
        for i in 1:8
            print(io, bonddims[i], " Ã— ")
        end
        print(io, " ... Ã— ", bonddims[L])
    else
        for i in 1:(L-1)
            print(io, bonddims[i], " Ã— ")
        end
        print(io, bonddims[L])
    end
end

function Base.show(io::IO, Ïˆ::MPS{L, T}) where {L, T}
    print(io, "MPS on $L sites")
end

#+END_SRC

#+HTML: <details><summary>Adjoint MPS</summary>
#+HTML: <p>

#+BEGIN_SRC julia :comments both :tangle src/MPS.jl
function Base.adjoint(Ïˆ::MPS{L, T}) where {L,T}
    Adjoint{T, MPS{L, T}}(Ïˆ)
end

function Base.show(io::IO, ::MIME"text/plain", Ïˆ::Adjoint{T, MPS{L, T}}) where {L, T}
    d = length(Ïˆ.parent[2][1, 1, :])
    bonddims = reverse([reverse(size(Ïˆ.parent[i][:, :, 1])) for i in 1:L])
    println(io, "Adjoint matrix product state on $L sites")
    _show_mps_dims(io, L, d, bonddims)
end

function Base.show(io::IO, Ïˆ::Adjoint{T, MPS{L, T}}) where {L, T}
    print(io, "Adjoint MPO on $L sites")t
end

Base.size(::Adjoint{T, MPS{L, T}}) where {L, T} = (1, L)

function Base.getindex(Ïˆ::Adjoint{T, MPS{L, T}}, args...) where {L, T}
    out = getindex(reverse(Ïˆ.parent.tensors), args...)
    permutedims(conj.(out), (2, 1, 3))
end

adjoint_tensors(Ïˆ::MPS) = reverse(conj.(permutedims.(Ïˆ.tensors, [(2, 1, 3)])))
#+END_SRC

#+HTML: </p>
#+HTML: </details>

#+HTML: <details><summary>MPS Contraction</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/contraction.jl

"""
    Base.:(*)(Ïˆâ€²::Adjoint{T, MPS{L, T}}, Ï•::MPS{L, T}) where {L, T}
representing
    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢       
    |           |           |           | 
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´
    |           |           |           | 
    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢
"""
function Base.:(*)(Ïˆâ€²::Adjoint{T, MPS{L, T}}, Ï•::MPS{L, T}) where {L, T}
    Ïˆ = Ïˆâ€².parent

    M   = Ï•.tensors[1]
    MÌƒdg = dg(Ïˆ.tensors[1])
    
    @tensor cont[bâ‚, aâ‚] := MÌƒdg[bâ‚, 1, Ïƒâ‚] * M[1, aâ‚, Ïƒâ‚]
    
    for i in 2:L-1
        M   = Ï•.tensors[i]
        MÌƒdg = dg(Ïˆ.tensors[i])

        @tensor cont[báµ¢, aáµ¢] := MÌƒdg[báµ¢, báµ¢â‚‹â‚, Ïƒáµ¢] * cont[báµ¢â‚‹â‚, aáµ¢â‚‹â‚] * M[aáµ¢â‚‹â‚, aáµ¢, Ïƒáµ¢]
    end
    M   = Ï•.tensors[L]
    MÌƒdg = dg(Ïˆ.tensors[L])
    
    @tensor MÌƒdg[1, bá´¸â»Â¹, Ïƒá´¸] * cont[bá´¸â»Â¹, aá´¸â»Â¹] * M[aá´¸â»Â¹, 1, Ïƒá´¸]
end

#+END_SRC

#+HTML: </p>
#+HTML: </details>

#+HTML: </p>
#+HTML: </details>

*** Matrix Product Operators
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/MPO.jl
"""
    MPO{L, T<:Number}

Matrix product operator on L sites. The `i`th tensor in the operator
has indices `[aâ±â»Â¹, aâ±, Ïƒâ±, Ïƒâ€²â±]` where `(Ïƒâ±, Ïƒâ€²â±)` are the physical
indices and `(aâ±â»Â¹, aâ±)` are bond indices.

A four site MPS would be diagrammatically represented

    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´
    |           |           |           | 
    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢     
    |           |           |           | 
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´


Note that `aâ°` and `aá´¸` must be of dimension 1.
"""
struct MPO{L, T<:Number}
    tensors::Vector{Array{T,4}}
end


"""
    MPO(W::Array{T,4}, L)
Create an `MPO` for `L` sites with all interior sites containing the tensor
`W`. The tensor is assumed to have the usual matrix-of-operators structure,
with the first two indices being the bond (matrix) dimension and the last two
indices being the physical (operator) dimension. The first and last sites only
use the last row and first column of `W`, respectively.

For example, the MPO form of the Hamiltonian for the TFIM is
constructed as with coupling `g` and length `L` is constructed as
follows:

    id = [1 0
          0 1]

    Ïƒá¶» = [1  0 
          0 -1]

    ÏƒË£ = [0 1
          1 0]

    ÏƒÊ¸ = [0  -im
          im   0]

    W = zeros(3, 3, 2, 2)
    W[1, 1, :, :] = id
    W[2, 1, :, :] = Ïƒá¶»
    W[3, 1, :, :] = -g*ÏƒË£
    W[3, 2, :, :] = -Ïƒá¶»
    W[3, 3, :, :] = id

returning 
 
    Ä¤::MPO = Å´Â¹ Å´Â² Å´Â³ â‹…â‹…â‹… Å´á´¸â»Â¹ Wá´¸
"""
function MPO(W::Array{T,4}, L) where {T}
    L >= 2 || throw(DomainError(L, "At least 2 sites."))

    tensors = Vector{Array{T,4}}(undef, L)
    
    tensors[1] = W[end:end, :, :, :] # Row vector.
    for i in 2:(L-1)
        tensors[i] = W # Matrix
    end
    tensors[L] = W[:, 1:1, :, :] # Column vector.

    MPO{L,T}(tensors)
end

Base.:(==)(O::MPO, U::MPO) = O.tensors == U.tensors
Base.:(â‰ˆ)(O::MPO, U::MPO)  = O.tensors â‰ˆ U.tensors
Base.getindex(O::MPO, args...) = getindex(O.tensors, args...)

function Base.show(io::IO, ::MIME"text/plain", O::MPO{L, T}) where {L, T}
    d = length(O[2][1, 1, 1, :])
    bonddims = [size(O[i][:, :, 1, 1]) for i in 1:L]
    println(io, "Matrix product Operator on $L sites")
    _show_mpo_dims(io, L, d, bonddims)
end

function _show_mpo_dims(io::IO, L, d, bonddims)
    println(io, "  Physical dimension: $d")
    print(io, "  Bond dimensions:   ")
    if L > 8
        for i in 1:8
            print(io, bonddims[i], " Ã— ")
        end
        print(io, " ... Ã— ", bonddims[L])
    else
        for i in 1:(L-1)
            print(io, bonddims[i], " Ã— ")
        end
        print(io, bonddims[L])
    end
end

function Base.show(io::IO, O::MPO{L, T}) where {L, T}
    print(io, "MPO on $L sites")
end
#+END_SRC 

#+HTML: <details><summary>MPO Contraction</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/contraction.jl
"""
    Base.:(*)(O::MPO, Ïˆ::MPS)
representing

    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´
    |           |           |           | 
    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢     
    |           |           |           | 
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´
    |           |           |           | 
    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢     
"""
function Base.:(*)(O::MPO{L, T}, Ïˆ::MPS{L, T}) where {L, T}
    tensors = Array{T,3}[]
    for i in 1:L
        W = O.tensors[i]
        M = Ïˆ.tensors[i]

        @reduce N[(báµ¢â‚‹â‚, aáµ¢â‚‹â‚), (báµ¢, aáµ¢), Ïƒáµ¢] :=  sum(Ïƒâ€²áµ¢) W[báµ¢â‚‹â‚, báµ¢, Ïƒáµ¢, Ïƒâ€²áµ¢] * M[aáµ¢â‚‹â‚, aáµ¢, Ïƒâ€²áµ¢]
        
        push!(tensors, N)
    end
    MPS{L, T}(tensors)
end


"""
    Base.:(*)(O1::MPO, O2::MPO)
representing

    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´
    |           |           |           | 
    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢     
    |           |           |           | 
    Ïƒâ€²â€²Â¹        Ïƒâ€²â€²Â²        Ïƒâ€²â€²Â³        Ïƒâ€²â€²â´
    Ïƒâ€²â€²Â¹        Ïƒâ€²â€²Â²        Ïƒâ€²â€²Â³        Ïƒâ€²â€²â´
    |           |           |           | 
    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢ 
    |           |           |           | 
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´    
"""
function Base.:(*)(O1::MPO{L, T}, O2::MPO{L, T}) where {L, T}
    tensors = Array{T,4}[]
    for i in 1:L
        W1 = O1.tensors[i]
        W2 = O2.tensors[i]

        @reduce V[(báµ¢â‚‹â‚, aáµ¢â‚‹â‚), (báµ¢, aáµ¢), Ïƒáµ¢, Ïƒâ€²áµ¢] :=  sum(Ïƒâ€²â€²áµ¢) W1[báµ¢â‚‹â‚, báµ¢, Ïƒáµ¢, Ïƒâ€²â€²áµ¢] * W2[aáµ¢â‚‹â‚, aáµ¢, Ïƒâ€²â€²áµ¢, Ïƒâ€²áµ¢]
        
        push!(tensors, V)
    end
    MPO{L, T}(tensors)
end

"""
    Base.:(*)(Ïˆ::Adjoint{T,MPS{L,T}}, O::MPO) where {L,T}
representing

    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢       
    |           |           |           | 
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´
    |           |           |           | 
    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢
    |           |           |           | 
    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´ 
"""
function Base.:(*)(Ïˆâ€²::Adjoint{T,MPS{L,T}}, O::MPO{L, T}) where {L,T}
    Ïˆ = Ïˆâ€².parent
    tensors = Array{T,3}[]
    Ws = dg.(reverse(O.tensors))
    for i in 1:L
        W = Ws[i]
        M = Ïˆ.tensors[i]

        @reduce N[(báµ¢â‚‹â‚, aáµ¢â‚‹â‚), (báµ¢, aáµ¢), Ïƒáµ¢] :=  sum(Ïƒâ€²áµ¢) W[báµ¢â‚‹â‚, báµ¢, Ïƒáµ¢, Ïƒâ€²áµ¢] * M[aáµ¢â‚‹â‚, aáµ¢, Ïƒâ€²áµ¢]
        push!(tensors, N)
    end
    adjoint(MPS{L, T}(tensors))
end
#+END_SRC 
#+HTML: </p>
#+HTML: </details>

#+HTML: </p>
#+HTML: </details>

*** Compression
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/compression.jl


function compress(Ïˆ::MPS{L, T}, to_the::Right; Dcut::Int=typemax(Int)) where {L, T}
    tensors = Array{T, 3}[]
    
    B = Ïˆ[1]
    d = length(B[1, 1, :])
    
    @cast Bm[(ÏƒÂ¹, aâ°), aÂ¹] |= B[aâ°, aÂ¹, ÏƒÂ¹]
    U, S, V = psvd(Bm, rank=Dcut)
    #S = S/âˆšsum(S .^ 2)

    @cast A[aâ°, aÂ¹, ÏƒÂ¹] |= U[(ÏƒÂ¹, aâ°), aÂ¹] (ÏƒÂ¹:d)
    push!(tensors, A)
    
    for i âˆˆ 2:L
        B = Ïˆ[i]
        d = length(B[1, 1, :])

        @tensor M[aâ±â»Â¹, aâ±, Ïƒâ±] := (Diagonal(S)*V')[aâ±â»Â¹, aâ±â»Â¹â€²] * B[aâ±â»Â¹â€², aâ±, Ïƒâ±]
        @cast   Mm[(Ïƒâ±, aâ±â»Â¹), aâ±] |= M[aâ±â»Â¹, aâ±, Ïƒâ±]
        
        U, S, V = psvd(Mm, rank=Dcut)
        #S = S/âˆšsum(S .^ 2)

        @cast A[aâ±â»Â¹, aâ±, Ïƒâ±] |= U[(Ïƒâ±, aâ±â»Â¹), aâ±] (Ïƒâ±:d)
        push!(tensors, A)
    end
    MPS{L, T}(tensors), Left()
end

leftcanonical(Ïˆ) = compress(Ïˆ, right)[1]

function compress(Ïˆ::MPS{L, T}, to_the::Left; Dcut::Int=typemax(Int)) where {L, T}
    tensors = Array{T, 3}[]
    
    A = Ïˆ[L]
    d = length(A[1, 1, :])
    @cast Am[aá´¸â»Â¹, (Ïƒá´¸, aá´¸)] |= A[aá´¸â»Â¹, aá´¸, Ïƒá´¸]
    
    U, S, V = psvd(Am, rank=Dcut)
    #S = S/âˆšsum(S .^ 2)    

    @cast B[aá´¸â»Â¹, aá´¸, Ïƒá´¸] |= V'[aá´¸â»Â¹, (Ïƒá´¸, aá´¸)] (Ïƒá´¸:d)
    push!(tensors, B)
    
    for i âˆˆ (L-1):-1:1
        A = Ïˆ[i]
        d = length(A[1, 1, :])
        @tensor M[aâ±â»Â¹, aâ±, Ïƒâ±]    := A[aâ±â»Â¹, aâ±â€², Ïƒâ±] * (U * Diagonal(S))[aâ±â€², aâ±]
        @cast   Mm[aâ±â»Â¹, (Ïƒâ±, aâ±)] |= M[aâ±â»Â¹, aâ±, Ïƒâ±]
        
        U, S, V = psvd(Mm, rank=Dcut)
        #S = S/âˆšsum(S .^ 2)

        @cast B[aâ±â»Â¹, aâ±, Ïƒâ±] |= V'[aâ±â»Â¹, (Ïƒâ±, aâ±)] (Ïƒâ±:d)
        push!(tensors, B)
    end
    MPS{L, T}(reverse(tensors)), Right()
end

rightcanonical(Ïˆ) = compress(Ïˆ, left)[1]

compress(Ïˆ; Dcut) = compress(Ïˆ, left, Dcut=Dcut)[1]

#+END_SRC 
#+HTML: </p>
#+HTML: </details>

*** Iterative Ground State Search
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/groundstate.jl

function R_exprs(Ïˆ::MPS{L, T}, H::MPO{L, T}) where {L, T}
    R_exs = Array{T, 3}[]
    R_ex = ones(T, 1, 1, 1)
    for l in L:-1:2
        R_ex = iterate_R_ex(Ïˆ[l], H[l], R_ex) 
        push!(R_exs, R_ex)
    end
    reverse(R_exs)
end

# function preallocate_hs(Ïˆ::MPS{L, T}) where {L, T}
#     h_tnsrs = map(Ïˆ.tensors) do M
#         DË¡â»Â¹, DË¡, d = size(M)
#         Array{T, 6}(undef, d, DË¡â»Â¹, DË¡, d, DË¡â»Â¹, DË¡)
#     end
# end


function sweep!(::Right, Ïˆ::MPS{L, T}, H::MPO{L, T}, R_exs) where {L, T}
    L_exs = Array{T, 3}[]
    L_ex  = ones(T, 1, 1, 1)
    E = zero(T)
    for l in 1:(L-1)
        W = H[l]
        
        E, A, SVp = eigenproblem(right, Ïˆ[l], L_ex, W, R_exs[l])
        Ïˆ.tensors[l] = A

        L_ex = iterate_L_ex(A, W, L_ex)
        push!(L_exs, L_ex)

        Bp1 = Ïˆ.tensors[l+1]
        @tensor Mp1[sâ±â»Â¹, aâ±, Ïƒâ±] := SVp[sâ±â»Â¹, aâ±â»Â¹] * Bp1[aâ±â»Â¹, aâ±, Ïƒâ±]
        Ïˆ.tensors[l+1] = Mp1
    end
    L_exs, E
end

function sweep!(::Left, Ïˆ::MPS{L, T}, H::MPO{L, T}, L_exs) where {L, T}
    R_exs = Array{T, 3}[]
    R_ex  = ones(T, 1, 1, 1)
    E = zero(T)
    for l in L:-1:2
        W = H[l]

        E, US, B = eigenproblem(left, Ïˆ[l], L_exs[l-1], W, R_ex)
        Ïˆ.tensors[l] = B

        R_ex = iterate_R_ex(B, W, R_ex) 
        push!(R_exs, R_ex)

        Am1 = Ïˆ.tensors[l-1]
        @tensor Mm1[aË¡â»Â², sË¡â»Â¹, ÏƒË¡â»Â¹] :=  Am1[aË¡â»Â², aË¡â»Â¹â€², ÏƒË¡â»Â¹] * US[aË¡â»Â¹â€², sË¡â»Â¹]
        Ïˆ.tensors[l-1] = Mm1
    end
    R_exs, E
end

function h_matrix(L_ex::Array{T,3}, W::Array{T,4}, R_ex::Array{T,3}) where {T}
    @tensor h[ÏƒË¡, aË¡â»Â¹, aË¡, ÏƒË¡â€², aË¡â»Â¹â€², aË¡â€²] := L_ex[bË¡â»Â¹, aË¡â»Â¹, aË¡â»Â¹â€²] * W[bË¡â»Â¹, bË¡, ÏƒË¡, ÏƒË¡â€²] * R_ex[bË¡, aË¡, aË¡â€²]
    @cast h[(ÏƒË¡, aË¡â»Â¹, aË¡), (ÏƒË¡â€², aË¡â»Â¹â€², aË¡â€²)] := h[ÏƒË¡, aË¡â»Â¹, aË¡, ÏƒË¡â€², aË¡â»Â¹â€², aË¡â€²]
end

function eigenproblem(dir::Direction, M::Array{T, 3}, L_ex::Array{T, 3}, W::Array{T, 4}, R_ex::Array{T, 3}) where {T}
    @cast v[(ÏƒË¡, aË¡â»Â¹, aË¡)] |= M[aË¡â»Â¹, aË¡, ÏƒË¡]
    
    h = h_matrix(L_ex, W, R_ex)
    Î», Î¦ = eigs(h, v0=v, nev=1, which=:SR)
    E  = Î»[1]::T 
    vâ° = (Î¦[:,1])::Vector{T}

    (E, split_tensor(dir, vâ°, size(M))...)
end

function split_tensor(::Right, vâ°::Vector, (DË¡â»Â¹, DË¡, d))
    @cast Mm[(ÏƒË¡, aË¡â»Â¹), aË¡] := vâ°[(ÏƒË¡, aË¡â»Â¹, aË¡)] (aË¡â»Â¹:DË¡â»Â¹, aË¡:DË¡, ÏƒË¡:d)
    U, S, V = svd(Mm)
    @cast A[aË¡â»Â¹, aË¡, ÏƒË¡] |= U[(ÏƒË¡, aË¡â»Â¹), aË¡] (ÏƒË¡:d, aË¡â»Â¹:DË¡â»Â¹, aË¡:DË¡)
    A, Diagonal(S)*V'
end

function split_tensor(::Left, vâ°::Vector, (DË¡â»Â¹, DË¡, d))
    @cast Mm[aË¡â»Â¹, (ÏƒË¡, aË¡)] |= vâ°[(ÏƒË¡, aË¡â»Â¹, aË¡)] (aË¡â»Â¹:DË¡â»Â¹, aË¡:DË¡, ÏƒË¡:d)
    U, S, V = svd(Mm)
    @cast B[aË¡â»Â¹, aË¡, ÏƒË¡] |= V'[aË¡â»Â¹, (ÏƒË¡, aË¡)] (ÏƒË¡:d)
    U*Diagonal(S), B
end

function iterate_R_ex(B, W, R_ex) where {T}
    @tensoropt R_exâ€²[bâ±â»Â¹, aâ±â»Â¹, aâ±â»Â¹â€²] := (conj.(B))[aâ±â»Â¹,aâ±,Ïƒâ±] * W[bâ±â»Â¹,bâ±,Ïƒâ±,Ïƒâ±â€²] * B[aâ±â»Â¹â€²,aâ±â€²,Ïƒâ±â€²] * R_ex[bâ±,aâ±,aâ±â€²]
end

function iterate_L_ex(A, W, L_ex) where {T}
    @tensoropt L_exâ€²[bË¡, aË¡, aË¡â€²] := L_ex[bË¡â»Â¹,aË¡â»Â¹,aË¡â»Â¹â€²] * (conj.(A))[aË¡â»Â¹,aË¡,ÏƒË¡] * W[bË¡â»Â¹,bË¡,ÏƒË¡,ÏƒË¡â€²] * A[aË¡â»Â¹â€²,aË¡â€²,ÏƒË¡â€²]
end


"""
    ground_state(Ïˆ::MPS{L, T}, H::MPO{L, T}; maxiter=10, quiet=false, Ïµ=1e-8) where {L, T}

Perform the finite system density matrix renormalization group
algorithm. First this will build up the R expressions, then do right
and left sweeps until either
 1) The state converges to an eigenstate `Ï•` such that
    Ï•' * H * H * Ï• â‰ˆ (Ï•' * H * Ï•) 
to the requested tolerance `Ïµ`
 2) The energy eigenvalue stops changing (possible signaling the algorithm is 
stuck in a local minimum)
 3) The number of full (right and left) sweeps exceeds `maxiter`. 

Setting `quiet=true` will suppress notifications about the algorithm's
progress but *not* warnings due to non-convergence.
"""
function ground_state(Ïˆ::MPS{L, T}, H::MPO{L, T}; maxiter=10, quiet=false, Ïµ=1e-8) where {L, T}
    Ï• = Ïˆ |> copy

    quiet || println("Computing R expressions")
    R_exs = R_exprs(Ïˆ, H)

    converged = false
    count     = 0
    Eâ‚€ = zero(T)
    enable_cache(maxsize=5*10^9)
    while not(converged)
        quiet || println("Performing right sweep")
        L_exs, Eâ‚€â€² = sweep!(right, Ï•, H, R_exs)

        quiet || println("Performing left sweep")
        R_exs, Eâ‚€  = sweep!(left,  Ï•, H, L_exs)

        count += 1
        if iseigenstate(Ï•, H, Ïµ=Ïµ)
            quiet || println("Converged in $count iterations")
            converged = true
        elseif count > 1 && Eâ‚€ â‰ˆ Eâ‚€â€²
                @warn """
Energy eigenvalue converged but state is not an eigenstate.
Consider either lowering your requested tolerance or 
implementing a warm-up algorithm to avoid local minima.
"""
            break
        elseif count >= maxiter
            @warn "Did not converge in $maxiter iterations"
            break
        end
    end
    clear_cache()
    Ï•, Eâ‚€
end


function iseigenstate(Ïˆ::MPS, H::MPO; Ïµ=1e-8)
    Ï• = rightcanonical(Ïˆ)
    isapprox(Ï•' * (H * H * Ï•), (Ï•' * (H * Ï•))^2, rtol=Ïµ)
end

#+END_SRC
#+HTML: </details>
#+HTML: </p>

*** Correlation Functions
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/correlation.jl

"""
    two_point_correlator((i, op_i)::Pair{Int, Matrix}, (j, op_j)::Pair{Int, Matrix}, L)

Create an MPO on `L` sites (with bond dimension 1) representing identity operators everywhere except
sites `i` and `j` where `op_i` and `op_j` are inserted instead. ie.

    ğŸ™ âŠ— ğŸ™ âŠ— ... âŠ— op_i âŠ— ğŸ™ âŠ— ... âŠ— op_j âŠ— ğŸ™ âŠ— ... âŠ— ğŸ™

example: spin-spin correlation function

we can construct âŸ¨Ïƒá¶»áµ¢Ïƒá¶»â±¼âŸ© on a 12 site lattice as
    Ïƒá¶» = [1 0; 0 -1]
    two_point_correlator(i=>Ïƒá¶», j=>Ïƒá¶», 12)  
"""
function two_point_correlator((i, op_i), (j, op_j), L)
    d = size(op_i)[1]
    @assert (size(op_i) == (d, d)) && (size(op_j) == (d, d))
    @assert i in 1:L
    @assert j in 1:L
    id = diagm(0 => ones(Complex{Float64}, d))

    op_i_tnsr = reshape(convert(Matrix{Complex{Float64}}, op_i), 1, 1, d, d) 
    op_j_tnsr = reshape(convert(Matrix{Complex{Float64}}, op_j), 1, 1, d, d)
    id_tnsr   = reshape(id, 1, 1, d, d)

    tensors = map(1:L) do l
        O_tnsr = (l == i ? op_i_tnsr : 
                  l == j ? op_j_tnsr : 
                  id_tnsr)
    end 
    MPO{L,Complex{Float64}}(tensors)
end




#+END_SRC
#+HTML: </details>
#+HTML: </p>
*** Imaginary Time Evolution
I don't think this works!
#+HTML: <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle src/timeevolution.jl

# Fixme! this does not appear to find ground states!

function _MPO_handed_time_evolver(hs::Vector{Matrix{T}}, Ï„, L, d) where {T}
    tensors = Array{T, 4}[]
    for h in hs
        O = exp(-Ï„*h)
        @cast P[(Ïƒâ±, Ïƒâ±â€²), (Ïƒâ±âºÂ¹, Ïƒâ±âºÂ¹â€²)] |= O[(Ïƒâ±, Ïƒâ±âºÂ¹), (Ïƒâ±â€², Ïƒâ±âºÂ¹â€²)] (Ïƒâ±:d, Ïƒâ±â€²:d)
        U, S, V = svd(P)

        @cast U[1, k, Ïƒâ±, Ïƒâ±â€²]     := U[(Ïƒâ±, Ïƒâ±â€²), k] * âˆš(S[k])      (Ïƒâ±:d)
        @cast Åª[k, 1, Ïƒâ±âºÂ¹, Ïƒâ±âºÂ¹â€²] := âˆš(S[k]) * V'[k, (Ïƒâ±âºÂ¹, Ïƒâ±âºÂ¹â€²)] (Ïƒâ±âºÂ¹:d)
        push!(tensors, U, Åª)
    end
    MPO{L, T}(tensors)
end

function MPO_time_evolvers(h1::Matrix, hi::Matrix, hL::Matrix, Ï„, L, d)
    if iseven(L)
        odd_hs  = [h1, [hi for _ in 3:2:(L-1)]...]
        even_hs = [[hi for i in 2:2:(L-1)]..., hL]
    else
        odd_hs  = [h1, [hi for _ in 3:2:(L-1)]..., hL]
        even_hs = [hi for i in 2:2:(L-1)]
    end
    
    Uodd  = _MPO_handed_time_evolver(odd_hs, Ï„, L, d)
    Ueven = _MPO_handed_time_evolver(even_hs, Ï„, L, d)
    Uodd, Ueven
end

function imag_time_evolution(Ïˆ::MPS{L, T}, h1::Matrix{T}, hi::Matrix{T}, hL::Matrix{T}, 
                             Î², N, Dcut) where {L, T}
    @warn "This probably still doesn't work!"
    Ï„ = Î²/N
    d = length(Ïˆ[1][1, 1, :])
    Ï• = Ïˆ  # Ground state guess
    dir = left
    Uodd, Ueven = MPO_time_evolvers(h1, hi, hL, Ï„, L, d)
    for _ in 1:N
        Ï•1, dir = compress(Uodd  * Ï•,  dir, Dcut=Dcut)
        Ï•,  dir = compress(Ueven * Ï•1, dir, Dcut=Dcut)
        #Ï•,  dir = compress(Uodd  * Ï•2, dir, Dcut=Dcut)
    end
    Ï•
end
#+END_SRC
#+HTML: </details>
#+HTML: </p>

** Tests
#+HTML:  <details><summary>Source</summary>
#+HTML: <p>
#+BEGIN_SRC julia :comments both :tangle test/runtests.jl
using Test, MatrixProductStates, SparseArrays, Arpack

@testset "TFIM   " begin
    g = 1.0; L = 7

    function H_TFIM(g, L)
        id = [1  0; 
              0  1]
        ÏƒË£ = [0  1; 
              1  0]
        Ïƒá¶» = [1  0; 
              0 -1]
        W_tnsr = zeros(Complex{Float64}, 3, 3, 2, 2)
        W_tnsr[1, 1, :, :] = id    
        W_tnsr[2, 1, :, :] = -Ïƒá¶»  
        W_tnsr[3, 1, :, :] = -g*ÏƒË£
        W_tnsr[3, 2, :, :] = Ïƒá¶»   
        W_tnsr[3, 3, :, :] = id   

        return MPO(W_tnsr, L)
    end
    H = H_TFIM(g, L)
    Ïˆ = randn(MPS{L, Complex{Float64}}, 100, 2)
    
    ÏˆÌƒ = compress(Ïˆ, left, Dcut=80)[1] # Note: no actual information is lost in this 
    # compression because of the small size of the chain

    @test              ÏˆÌƒ'ÏˆÌƒ â‰ˆ 1
    @test          Ïˆ'Ïˆ/Ïˆ'Ïˆ â‰ˆ ÏˆÌƒ'ÏˆÌƒ
    @test ((Ïˆ'*(H*Ïˆ))/Ïˆ'Ïˆ) â‰ˆ (ÏˆÌƒ' * (H * ÏˆÌƒ))/ÏˆÌƒ'ÏˆÌƒ
    @test ((Ïˆ'*(H*Ïˆ))/Ïˆ'Ïˆ) â‰ˆ (ÏˆÌƒ' * (H * Ïˆ))/ÏˆÌƒ'Ïˆ

    Ï•, Eâ‚€ = ground_state(Ïˆ, H, quiet=true)
    @test Ï•' * H * H * Ï• â‰ˆ (Ï•'*H*Ï•)^2
end

@testset "Hubbard" begin

    id = [1 0
          0 1]
    c  = [0 0
          1 0] #Anti commuting matrix
    c_up = c  âŠ— id
    c_dn = id âŠ— c
    idÂ²  = id âŠ— id
    n_up = c_up' * c_up
    n_dn = c_dn' * c_dn

    P_up = (idÂ² - 2c_up'*c_up) # Spin up parity operator
    P_dn = (idÂ² - 2c_dn'*c_dn) # Spin down parity operator

    function H_hub(U, Î¼, L)
        W_tnsr = zeros(Complex{Float64}, 6, 6, 4, 4)
        W_tnsr[1, 1, :, :] = idÂ²
        W_tnsr[2, 1, :, :] = c_up'
        W_tnsr[3, 1, :, :] = c_dn'
        W_tnsr[4, 1, :, :] = c_up
        W_tnsr[5, 1, :, :] = c_dn
        W_tnsr[6, 1, :, :] = U*(n_up * n_dn) - Î¼*(n_up + n_dn)
        W_tnsr[6, 2, :, :] =  c_up  * P_up  # Must multiply by the parity operator to get 
        W_tnsr[6, 3, :, :] =  c_dn  * P_dn  # correct off-site commutation relations!
        W_tnsr[6, 4, :, :] = -c_up' * P_up
        W_tnsr[6, 5, :, :] = -c_dn' * P_dn
        W_tnsr[6, 6, :, :] = idÂ²
        MPO(W_tnsr, L)
    end

    function solve_hub(U, Î¼, L; retfull=true, quiet=true)
        H = H_hub(U, Î¼, L)
        Ïˆ = randn(MPS{L, Complex{Float64}}, 100, 4)
        (Ï•, Eâ‚€), t, bytes = @timed ground_state(Ïˆ, H, Ïµ=1e-5, quiet=quiet)

        (Ï•=Ï•, Eâ‚€=Eâ‚€, H=H, t=t, Gbytes=bytes/1e9)
    end

    function Hub_ED(U, Î¼, L,)
        UÌ‚ = U*(n_up * n_dn) - Î¼*(n_up + n_dn)
        c_dg_up(i) = foldl(âŠ—, sparse.([i==j ? c_up' : idÂ² for j in 1:L]))
        cup(i)     = foldl(âŠ—, sparse.([i==j ? c_up  : idÂ² for j in 1:L]))
        c_dg_dn(i) = foldl(âŠ—, sparse.([i==j ? c_dn' : idÂ² for j in 1:L]))
        cdn(i)     = foldl(âŠ—, sparse.([i==j ? c_dn  : idÂ² for j in 1:L]))
        UÌ‚f(i)      = foldl(âŠ—, sparse.([i==j ? UÌ‚     : idÂ² for j in 1:L]))
        function c_dg_c(i) 
            out = c_dg_up(i)*cup(i+1) + c_dg_dn(i)*cdn(i+1)
            out + out'
        end
        H = -sum(c_dg_c, 1:(L-1)) + sum(UÌ‚f, 1:L)

        Î», Ï• = eigs(H, nev=1, which=:SR)
        (Ï•'H*Ï•)[]
    end

   
    U = 3.0; Î¼ = -1.0; L = 4
    H = H_hub(U, Î¼, L)

    Ï•, Eâ‚€ = solve_hub(U, Î¼, L, retfull=true, quiet=true)
    @test Ï•' * H * H * Ï• â‰ˆ (Ï•'*H*Ï•)^2  # Make sure energy is eigenvalue
    @test Ï•' * H * Ï• â‰ˆ Eâ‚€              # make sure eigenvalue matches one produced by alogrithm
    @test Ï•' * H * Ï• â‰ˆ Hub_ED(U, Î¼, L) # check against exact diagonalization
end

#+END_SRC
#+HTML: </details>
#+HTML: </p>
